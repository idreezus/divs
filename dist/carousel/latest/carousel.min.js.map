{"version":3,"file":"carousel.min.js","sources":["../../../packages/carousel/src/config.js","../../../packages/carousel/src/utils.js","../../../packages/carousel/src/autoplay.js","../../../packages/carousel/src/navigation.js","../../../packages/carousel/src/keyboard.js","../../../packages/carousel/src/core.js","../../../packages/carousel/src/carousel.js"],"sourcesContent":["export const SELECTORS = {\n  CONTAINER: '[data-carousel=\"container\"]',\n  TRACK: '[data-carousel=\"track\"]',\n  ITEM: '[data-carousel=\"item\"]',\n  PREV_BTN: '[data-carousel=\"prev\"]',\n  NEXT_BTN: '[data-carousel=\"next\"]',\n  DOT: '[data-carousel-dot]',\n  PAGINATION_CURRENT: '[data-carousel-pagination-current]',\n  PAGINATION_TOTAL: '[data-carousel-pagination-total]',\n  PLAY_PAUSE_BTN: '[data-carousel-play-pause]',\n};\n\n// CSS classes applied to elements\nexport const CLASSES = {\n  SCROLLING: 'carousel-scrolling', // Applied to track while user or programmatic scroll is active\n  DISABLED: 'carousel-button-disabled', // Applied to buttons when at start/end edges\n  ACTIVE: 'carousel-item-active', // Applied to the current active item\n  VISIBLE: 'carousel-item-visible', // Applied to items currently in viewport (reserved for future use)\n  ANIMATING: 'carousel-animating', // Applied to track during programmatic scroll\n  SNAP_DISABLED: 'carousel-snap-disabled', // Applied to track to temporarily disable scroll-snap during button navigation\n  DOT_ACTIVE: 'carousel-dot-active', // Applied to the current active pagination dot\n  LIVE_REGION: 'carousel-sr-only', // Applied to the live region for screen readers\n  AUTOPLAY_ACTIVE: 'carousel-autoplay-active',\n  AUTOPLAY_PAUSED: 'carousel-autoplay-paused',\n  REDUCED_MOTION: 'carousel-reduced-motion',\n};\n\nexport const DEFAULTS = {\n  ALIGN: 'start',\n  KEYBOARD: false,\n  SCROLL_BY: 'item',\n  LOOP: false,\n  AUTOPLAY: false,\n  AUTOPLAY_DURATION: 5000,\n  AUTOPLAY_PAUSE_HOVER: true,\n  AUTOPLAY_PAUSE_FOCUS: true,\n};\n\n// Timing constants in milliseconds\nexport const TIMING = {\n  DEBOUNCE_RESIZE: 150,\n  DEBOUNCE_SCROLL: 100,\n  BUTTON_COOLDOWN: 100,\n  SNAP_DISABLE_DURATION: 50,\n};\n\n// Pixel tolerance for fractional pixel calculations\nexport const TOLERANCE = {\n  EDGE_DETECTION: 1,\n  ACTIVE_DETECTION: 2,\n};\n\n// CSS custom property names\nexport const CSS_VARS = {\n  INDEX: '--carousel-index',\n  TOTAL: '--carousel-total',\n  PROGRESS: '--carousel-progress',\n  AUTOPLAY_PROGRESS: '--carousel-autoplay-progress',\n  AUTOPLAY_DURATION: '--carousel-autoplay-duration',\n};\n\n// Event names for CustomEvents\nexport const EVENTS = {\n  CHANGE: 'change',\n  SCROLL: 'scroll',\n  REACH_START: 'reach-start',\n  REACH_END: 'reach-end',\n  AUTOPLAY_START: 'autoplay-start',\n  AUTOPLAY_PAUSE: 'autoplay-pause',\n};\n\n// Data attribute names for configuration\nexport const ATTRIBUTES = {\n  AUTOPLAY: 'data-carousel-autoplay',\n  AUTOPLAY_DURATION: 'data-carousel-autoplay-duration',\n  AUTOPLAY_PAUSE_HOVER: 'data-carousel-autoplay-pause-hover',\n  AUTOPLAY_PAUSE_FOCUS: 'data-carousel-autoplay-pause-focus',\n  SCROLL_BY: 'data-carousel-scroll-by',\n};\n\nexport const CONFIG = {\n  SELECTORS,\n  CLASSES,\n  DEFAULTS,\n  TIMING,\n  TOLERANCE,\n  CSS_VARS,\n  EVENTS,\n  ATTRIBUTES,\n};\n","// Pure utility functions for the carousel library\n\nimport { DEFAULTS, CSS_VARS } from './config.js';\n\n// Counter for generating unique carousel IDs\nlet idCounter = 0;\n\n// Generates a unique ID for each carousel instance\nexport function generateUniqueId() {\n  idCounter += 1;\n  return `carousel-${idCounter}`;\n}\n\n// Parses configuration from data attributes on the container element\nexport function parseConfig(container) {\n  const align = container.getAttribute('data-carousel-align') || DEFAULTS.ALIGN;\n  const keyboard = container.getAttribute('data-carousel-keyboard') === 'true';\n  const loop = container.getAttribute('data-carousel-loop') === 'true';\n  const scrollBy = container.getAttribute('data-carousel-scroll-by') || DEFAULTS.SCROLL_BY;\n  const autoplay = container.getAttribute('data-carousel-autoplay') === 'true';\n  const autoplayDuration = parseInt(container.getAttribute('data-carousel-autoplay-duration'), 10) || DEFAULTS.AUTOPLAY_DURATION;\n  const autoplayPauseHover = container.getAttribute('data-carousel-autoplay-pause-hover') !== 'false';\n  const autoplayPauseFocus = container.getAttribute('data-carousel-autoplay-pause-focus') !== 'false';\n\n  return {\n    align,\n    keyboard,\n    loop,\n    scrollBy,\n    autoplay,\n    autoplayDuration,\n    autoplayPauseHover,\n    autoplayPauseFocus,\n  };\n}\n\n// Checks if the user prefers reduced motion\nexport function prefersReducedMotion() {\n  return window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n}\n\n// Creates a debounced version of a function\nexport function debounce(func, wait) {\n  let timeout;\n\n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// Calculates the reference point for snap alignment detection\nfunction calculateReferencePoint(\n  scrollLeft,\n  containerWidth,\n  snapAlign,\n  offsets = {}\n) {\n  const { startInset = 0, endInset = 0 } = offsets;\n  switch (snapAlign) {\n    case 'center':\n      return scrollLeft + containerWidth / 2 + (startInset - endInset) / 2;\n    case 'end':\n      return scrollLeft + containerWidth - endInset;\n    default: // 'start'\n      return scrollLeft + startInset;\n  }\n}\n\n// Gets the alignment point for a specific item based on snap alignment\nfunction getItemAlignmentPoint(item, snapAlign) {\n  const marginStart = item.marginStart || 0;\n  const marginEnd = item.marginEnd || 0;\n  switch (snapAlign) {\n    case 'center':\n      return item.center + (marginEnd - marginStart) / 2;\n    case 'end':\n      return item.right + marginEnd;\n    default: // 'start'\n      return item.left - marginStart;\n  }\n}\n\n// Finds the index of the active item based on scroll position\nexport function findActiveIndex(\n  itemPositions,\n  scrollLeft,\n  containerWidth,\n  snapAlign,\n  options = {}\n) {\n  const { startInset = 0, endInset = 0 } = options;\n  const referencePoint = calculateReferencePoint(\n    scrollLeft,\n    containerWidth,\n    snapAlign,\n    { startInset, endInset }\n  );\n\n  let closestIndex = 0;\n  let minDistance = Infinity;\n  const distances = [];\n\n  itemPositions.forEach((item, index) => {\n    const itemPoint = getItemAlignmentPoint(item, snapAlign);\n    const distance = Math.abs(itemPoint - referencePoint);\n\n    distances.push({ index, itemPoint, distance });\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestIndex = index;\n    }\n  });\n\n  return closestIndex;\n}\n\n// Finds the target index when scrolling forward by one container width\nexport function findNextPageIndex(instance) {\n  const { track, state, items, config } = instance;\n  const { itemPositions, containerWidth } = state;\n  const targetLeft = track.scrollLeft + containerWidth;\n\n  for (let i = state.currentIndex + 1; i < itemPositions.length; i++) {\n    if (itemPositions[i].left >= targetLeft) return i;\n  }\n\n  // Near the end\n  return config.loop ? 0 : items.length - 1;\n}\n\n// Finds the target index when scrolling backward by one container width\nexport function findPrevPageIndex(instance) {\n  const { track, state, items, config } = instance;\n  const { itemPositions, containerWidth } = state;\n  const targetLeft = track.scrollLeft - containerWidth;\n\n  for (let i = state.currentIndex - 1; i >= 0; i--) {\n    if (itemPositions[i].left <= targetLeft) return i;\n  }\n\n  // Near the start\n  return config.loop ? items.length - 1 : 0;\n}\n\n// Returns the total number of slides for the provided collection of items\nexport function calculateTotalSlides(items) {\n  if (!Array.isArray(items)) {\n    return 0;\n  }\n\n  return items.length;\n}\n\n// Emits custom events both through the instance event system and as DOM events\nexport function emit(instance, event, data = {}) {\n  const { events, container } = instance;\n\n  // Call registered callbacks via instance.on()\n  if (events.has(event)) {\n    const callbacks = events.get(event);\n    callbacks.forEach((callback) => {\n      callback.call(instance, {\n        type: event,\n        target: instance,\n        ...data,\n      });\n    });\n  }\n\n  // Dispatch native DOM custom event for addEventListener compatibility\n  const customEvent = new CustomEvent(`carousel:${event}`, {\n    detail: { carousel: instance, ...data },\n    bubbles: true,\n  });\n  container.dispatchEvent(customEvent);\n}\n\n// Calculates and stores all dimensional measurements for the carousel\nexport function calculateDimensions(instance) {\n  const { track, items, state, config } = instance;\n\n  // Get computed styles to read CSS properties\n  const trackStyle = getComputedStyle(track);\n\n  const parseOffset = (value) => {\n    if (!value || value === 'auto') {\n      return { value: 0, specified: false };\n    }\n    const parsed = parseFloat(value);\n    if (Number.isNaN(parsed)) {\n      return { value: 0, specified: false };\n    }\n    return { value: parsed, specified: true };\n  };\n\n  // Read gap from CSS (try both gap and column-gap for compatibility)\n  const gap = parseFloat(trackStyle.gap || trackStyle.columnGap) || 0;\n\n  const paddingInlineStart = parseOffset(\n    trackStyle.paddingInlineStart || trackStyle.paddingLeft\n  );\n  const paddingInlineEnd = parseOffset(\n    trackStyle.paddingInlineEnd || trackStyle.paddingRight\n  );\n  const scrollPaddingInlineStart = parseOffset(\n    trackStyle.scrollPaddingInlineStart || trackStyle.scrollPaddingLeft\n  );\n  const scrollPaddingInlineEnd = parseOffset(\n    trackStyle.scrollPaddingInlineEnd || trackStyle.scrollPaddingRight\n  );\n\n  const startInset = scrollPaddingInlineStart.specified\n    ? scrollPaddingInlineStart.value\n    : paddingInlineStart.value;\n  const endInset = scrollPaddingInlineEnd.specified\n    ? scrollPaddingInlineEnd.value\n    : paddingInlineEnd.value;\n\n  // Measure container and scroll dimensions\n  const containerWidth = track.clientWidth;\n  const scrollWidth = track.scrollWidth;\n\n  // Calculate basic position data for active item detection\n  const trackRect = track.getBoundingClientRect();\n  const itemPositions = items.map((item, index) => {\n    const rect = item.getBoundingClientRect();\n    const itemStyle = getComputedStyle(item);\n\n    // Read scroll-margin for detection calculations\n    const marginStartValue = parseFloat(\n      itemStyle.scrollMarginInlineStart || itemStyle.scrollMarginLeft\n    );\n    const marginEndValue = parseFloat(\n      itemStyle.scrollMarginInlineEnd || itemStyle.scrollMarginRight\n    );\n    const marginStart = Number.isNaN(marginStartValue) ? 0 : marginStartValue;\n    const marginEnd = Number.isNaN(marginEndValue) ? 0 : marginEndValue;\n\n    // Calculate left position relative to track, accounting for current scroll\n    const left = rect.left - trackRect.left + track.scrollLeft;\n    const width = rect.width;\n\n    return {\n      index,\n      left,\n      width,\n      center: left + width / 2,\n      right: left + width,\n      marginStart,\n      marginEnd,\n    };\n  });\n\n  // Update state with measurements needed for detection\n  Object.assign(state, {\n    gap,\n    containerWidth,\n    scrollWidth,\n    itemPositions,\n    startInset,\n    endInset,\n  });\n\n  // Store snap alignment on instance for reference\n  instance.snapAlign = config.align;\n}\n\n// Updates CSS custom properties on the carousel container\nexport function updateCSSProperties(instance) {\n  const { container, track, items, state } = instance;\n  const { currentIndex, scrollWidth, containerWidth } = state;\n\n  // Set one-based index for display friendliness\n  container.style.setProperty(CSS_VARS.INDEX, currentIndex + 1);\n\n  // Set total item count\n  container.style.setProperty(CSS_VARS.TOTAL, items.length);\n\n  // Calculate progress (0-1) based on scroll position\n  const maxScroll = scrollWidth - containerWidth;\n  const scrollLeft = track.scrollLeft;\n  const progress =\n    maxScroll > 0 ? Math.min(1, Math.max(0, scrollLeft / maxScroll)) : 0;\n  container.style.setProperty(CSS_VARS.PROGRESS, progress);\n}\n","// Autoplay behavior for carousel: timer, progress updates, pause/resume\n\nimport { CLASSES, CSS_VARS, EVENTS } from './config.js';\nimport { emit } from './utils.js';\n\n// RAF tick loop for autoplay progress\nfunction runAutoplayTick(instance) {\n  const { state, config, autoplay } = instance;\n\n  if (!state.isAutoplaying || state.isPaused) return;\n\n  const elapsed = performance.now() - state.autoplayStartTime;\n  const progress = Math.min(elapsed / config.autoplayDuration, 1);\n\n  // Update progress on container\n  instance.container.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, progress.toString());\n\n  // Update progress on active dot, reset inactive dots\n  if (instance.dots?.length > 0) {\n    instance.dots.forEach((dot, index) => {\n      if (index === state.currentIndex) {\n        dot.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, progress.toString());\n      } else {\n        dot.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, '0');\n      }\n    });\n  }\n\n  if (progress >= 1) {\n    instance.next();\n    state.autoplayStartTime = performance.now();\n  }\n\n  autoplay.rafId = requestAnimationFrame(() => runAutoplayTick(instance));\n}\n\n// Checks if autoplay can resume based on all pause conditions\nfunction canResume(instance) {\n  const { autoplay } = instance;\n  return (\n    autoplay.isVisible &&\n    !autoplay.pausedByHover &&\n    !autoplay.pausedByFocus &&\n    !autoplay.pausedByUser\n  );\n}\n\n// Sets up autoplay with IntersectionObserver and pause handlers\nexport function setupAutoplay(instance) {\n  const { container, config } = instance;\n\n  instance.autoplay = {\n    rafId: null,\n    observer: null,\n    isVisible: true,\n    pausedByHover: false,\n    pausedByFocus: false,\n    pausedByUser: false,\n  };\n\n  // IntersectionObserver to pause when out of viewport\n  instance.autoplay.observer = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        instance.autoplay.isVisible = entry.isIntersecting;\n        if (!entry.isIntersecting) {\n          pauseAutoplay(instance, 'visibility');\n        } else if (canResume(instance)) {\n          resumeAutoplay(instance);\n        }\n      });\n    },\n    { threshold: 0.5 }\n  );\n  instance.autoplay.observer.observe(container);\n\n  // Hover pause handlers\n  if (config.autoplayPauseHover) {\n    instance.autoplay.handleMouseEnter = () => {\n      instance.autoplay.pausedByHover = true;\n      pauseAutoplay(instance, 'hover');\n    };\n    instance.autoplay.handleMouseLeave = () => {\n      instance.autoplay.pausedByHover = false;\n      if (canResume(instance)) {\n        resumeAutoplay(instance);\n      }\n    };\n    container.addEventListener('mouseenter', instance.autoplay.handleMouseEnter);\n    container.addEventListener('mouseleave', instance.autoplay.handleMouseLeave);\n  }\n\n  // Focus pause handlers\n  if (config.autoplayPauseFocus) {\n    instance.autoplay.handleFocusIn = () => {\n      instance.autoplay.pausedByFocus = true;\n      pauseAutoplay(instance, 'focus');\n    };\n    instance.autoplay.handleFocusOut = (e) => {\n      // Only resume if focus leaves the container entirely\n      if (!container.contains(e.relatedTarget)) {\n        instance.autoplay.pausedByFocus = false;\n        if (canResume(instance)) {\n          resumeAutoplay(instance);\n        }\n      }\n    };\n    container.addEventListener('focusin', instance.autoplay.handleFocusIn);\n    container.addEventListener('focusout', instance.autoplay.handleFocusOut);\n  }\n}\n\n// Starts autoplay timer with RAF progress updates\nexport function startAutoplay(instance) {\n  const { container, state } = instance;\n\n  state.isAutoplaying = true;\n  state.isPaused = false;\n  state.autoplayStartTime = performance.now();\n\n  container.classList.add(CLASSES.AUTOPLAY_ACTIVE);\n  container.classList.remove(CLASSES.AUTOPLAY_PAUSED);\n\n  // Update play/pause button\n  if (instance.playPauseBtn) {\n    instance.playPauseBtn.setAttribute('aria-pressed', 'true');\n  }\n\n  emit(instance, EVENTS.AUTOPLAY_START, { index: state.currentIndex });\n\n  instance.autoplay.rafId = requestAnimationFrame(() =>\n    runAutoplayTick(instance)\n  );\n}\n\n// Pauses autoplay\nexport function pauseAutoplay(instance, reason = 'user') {\n  const { state, container } = instance;\n\n  if (!state.isAutoplaying || state.isPaused) return;\n\n  state.isPaused = true;\n\n  // Track user-initiated pause separately (sticky)\n  if (reason === 'user' || reason === 'keyboard') {\n    instance.autoplay.pausedByUser = true;\n  }\n\n  // Cancel RAF\n  if (instance.autoplay.rafId) {\n    cancelAnimationFrame(instance.autoplay.rafId);\n    instance.autoplay.rafId = null;\n  }\n\n  container.classList.add(CLASSES.AUTOPLAY_PAUSED);\n\n  // Update play/pause button\n  if (instance.playPauseBtn) {\n    instance.playPauseBtn.setAttribute('aria-pressed', 'false');\n  }\n\n  // Store elapsed time and active index so we can resume from this point\n  const elapsed = performance.now() - state.autoplayStartTime;\n  state.autoplayElapsed = elapsed;\n  state.autoplayPausedOnIndex = state.currentIndex;\n  const progress = Math.min(elapsed / instance.config.autoplayDuration, 1);\n\n  emit(instance, EVENTS.AUTOPLAY_PAUSE, {\n    index: state.currentIndex,\n    progress,\n  });\n}\n\n// Resumes autoplay from where it was paused\nexport function resumeAutoplay(instance) {\n  const { state, container } = instance;\n\n  if (!state.isAutoplaying || !state.isPaused) return;\n  if (!canResume(instance)) return;\n\n  state.isPaused = false;\n  // Resume from stored elapsed time only if still on the same slide, otherwise reset\n  const sameSlide = state.autoplayPausedOnIndex === state.currentIndex;\n  state.autoplayStartTime = sameSlide\n    ? performance.now() - (state.autoplayElapsed || 0)\n    : performance.now();\n\n  container.classList.remove(CLASSES.AUTOPLAY_PAUSED);\n\n  // Update play/pause button\n  if (instance.playPauseBtn) {\n    instance.playPauseBtn.setAttribute('aria-pressed', 'true');\n  }\n\n  emit(instance, EVENTS.AUTOPLAY_START, { index: state.currentIndex });\n\n  instance.autoplay.rafId = requestAnimationFrame(() =>\n    runAutoplayTick(instance)\n  );\n}\n\n// Stops autoplay completely\nexport function stopAutoplay(instance) {\n  const { state, container } = instance;\n\n  state.isAutoplaying = false;\n  state.isPaused = false;\n\n  if (instance.autoplay?.rafId) {\n    cancelAnimationFrame(instance.autoplay.rafId);\n    instance.autoplay.rafId = null;\n  }\n\n  container.classList.remove(CLASSES.AUTOPLAY_ACTIVE, CLASSES.AUTOPLAY_PAUSED);\n\n  // Reset progress on container\n  container.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, '0');\n\n  // Reset progress on all dots\n  if (instance.dots?.length > 0) {\n    instance.dots.forEach((dot) => {\n      dot.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, '0');\n    });\n  }\n}\n\n// Cleans up autoplay listeners and observer\nexport function cleanupAutoplay(instance) {\n  const { container, config, autoplay } = instance;\n\n  if (!autoplay) return;\n\n  // Cancel RAF\n  if (autoplay.rafId) {\n    cancelAnimationFrame(autoplay.rafId);\n  }\n\n  // Disconnect IntersectionObserver\n  if (autoplay.observer) {\n    autoplay.observer.disconnect();\n  }\n\n  // Remove hover listeners\n  if (config.autoplayPauseHover && autoplay.handleMouseEnter) {\n    container.removeEventListener('mouseenter', autoplay.handleMouseEnter);\n    container.removeEventListener('mouseleave', autoplay.handleMouseLeave);\n  }\n\n  // Remove focus listeners\n  if (config.autoplayPauseFocus && autoplay.handleFocusIn) {\n    container.removeEventListener('focusin', autoplay.handleFocusIn);\n    container.removeEventListener('focusout', autoplay.handleFocusOut);\n  }\n\n  instance.autoplay = null;\n}\n","// Navigation and pagination functionality\n\nimport { CONFIG } from './config.js';\nimport {\n  findActiveIndex,\n  findNextPageIndex,\n  findPrevPageIndex,\n  debounce,\n  calculateTotalSlides,\n  emit,\n  calculateDimensions,\n  updateCSSProperties,\n} from './utils.js';\nimport { updateActiveClasses } from './keyboard.js';\nimport { pauseAutoplay } from './autoplay.js';\n\n// Detects which item is currently active based on scroll position\nexport function detectActiveItem(instance) {\n  const { track, state, snapAlign } = instance;\n  const { itemPositions, currentIndex, startInset = 0, endInset = 0 } = state;\n\n  // Find the active index using scroll position\n  const scrollLeft = track.scrollLeft;\n  const activeIndex = findActiveIndex(\n    itemPositions,\n    scrollLeft,\n    state.containerWidth,\n    snapAlign,\n    {\n      startInset,\n      endInset,\n    }\n  );\n\n  // Only update if the active item has changed\n  if (activeIndex !== currentIndex) {\n    state.currentIndex = activeIndex;\n    updateUI(instance);\n    emit(instance, 'change', { index: activeIndex });\n  }\n}\n\n// Updates the disabled state of navigation buttons based on scroll position\nexport function updateButtonStates(instance) {\n  const { track, prevBtn, nextBtn, state, config } = instance;\n  const { CLASSES, TOLERANCE } = CONFIG;\n\n  const scrollLeft = track.scrollLeft;\n  const { scrollWidth, containerWidth } = state;\n  const maxScroll = scrollWidth - containerWidth;\n\n  // Detect edges with tolerance for fractional pixels\n  const atStart = scrollLeft <= TOLERANCE.EDGE_DETECTION;\n  const atEnd = scrollLeft >= maxScroll - TOLERANCE.EDGE_DETECTION;\n\n  if (config.loop) {\n    // Never disable buttons when looping\n    if (prevBtn) {\n      prevBtn.classList.remove(CLASSES.DISABLED);\n      prevBtn.disabled = false;\n    }\n    if (nextBtn) {\n      nextBtn.classList.remove(CLASSES.DISABLED);\n      nextBtn.disabled = false;\n    }\n  } else {\n    // Update prev button state\n    if (prevBtn) {\n      prevBtn.classList.toggle(CLASSES.DISABLED, atStart);\n      prevBtn.disabled = atStart;\n    }\n\n    // Update next button state\n    if (nextBtn) {\n      nextBtn.classList.toggle(CLASSES.DISABLED, atEnd);\n      nextBtn.disabled = atEnd;\n    }\n  }\n\n  // Edge events fire regardless of loop mode (physical scroll position)\n  if (atStart && !state.hasEmittedStart) {\n    emit(instance, 'reach-start');\n    state.hasEmittedStart = true;\n  } else if (!atStart) {\n    state.hasEmittedStart = false;\n  }\n\n  if (atEnd && !state.hasEmittedEnd) {\n    emit(instance, 'reach-end');\n    state.hasEmittedEnd = true;\n  } else if (!atEnd) {\n    state.hasEmittedEnd = false;\n  }\n}\n\n// Handles scroll events on the track\nexport function handleScroll(instance) {\n  const { track } = instance;\n  const { CLASSES, TIMING } = CONFIG;\n\n  // Detect user-initiated scroll (not programmatic) and pause autoplay\n  if (!instance.state.isAnimating && instance.state.isAutoplaying && !instance.state.isPaused) {\n    pauseAutoplay(instance, 'user');\n  }\n\n  // Add scrolling class immediately for instant feedback\n  track.classList.add(CLASSES.SCROLLING);\n\n  // Emit scroll event with current position\n  emit(instance, 'scroll', { scrollLeft: track.scrollLeft });\n\n  // Create debounced handler on first scroll (lazy initialization)\n  if (!instance.debouncedScrollHandler) {\n    instance.debouncedScrollHandler = debounce(() => {\n      detectActiveItem(instance);\n      updateButtonStates(instance);\n      track.classList.remove(CLASSES.SCROLLING);\n    }, TIMING.DEBOUNCE_SCROLL);\n  }\n\n  // Execute debounced handler\n  instance.debouncedScrollHandler();\n}\n\n// Calculates the index of the next item for navigation\nexport function calculateNextIndex(instance) {\n  const { state, items, config } = instance;\n\n  if (config.scrollBy === 'page') return findNextPageIndex(instance);\n\n  const nextIndex = state.currentIndex + 1;\n  if (nextIndex > items.length - 1) {\n    return config.loop ? 0 : items.length - 1;\n  }\n  return nextIndex;\n}\n\n// Calculates the index of the previous item for navigation\nexport function calculatePrevIndex(instance) {\n  const { state, items, config } = instance;\n\n  if (config.scrollBy === 'page') return findPrevPageIndex(instance);\n\n  const prevIndex = state.currentIndex - 1;\n  if (prevIndex < 0) {\n    return config.loop ? items.length - 1 : 0;\n  }\n  return prevIndex;\n}\n\n// Scrolls to a specific item index with smooth animation\nexport function scrollToItem(instance, index) {\n  const { track, items, state, snapAlign } = instance;\n  const { CLASSES, TIMING } = CONFIG;\n\n  const targetItem = items[index];\n  if (!targetItem) {\n    console.warn(`Carousel ${instance.id}: No item found at index ${index}`);\n    return;\n  }\n\n  // Mark as animating to prevent concurrent navigation\n  state.isAnimating = true;\n  track.classList.add(CLASSES.ANIMATING);\n  track.classList.add(CLASSES.SNAP_DISABLED);\n\n  // Browser handles positioning with respect to scroll-padding and scroll-margin\n  targetItem.scrollIntoView({\n    behavior: 'smooth',\n    block: 'nearest',\n    container: 'nearest',\n    inline: snapAlign, // 'start', 'center', or 'end'\n  });\n\n  // Re-enable scroll-snap after short delay so native snap can take over\n  setTimeout(() => {\n    track.classList.remove(CLASSES.SNAP_DISABLED);\n  }, TIMING.SNAP_DISABLE_DURATION);\n\n  // Remove animating state after cooldown period\n  setTimeout(() => {\n    state.isAnimating = false;\n    track.classList.remove(CLASSES.ANIMATING);\n  }, TIMING.BUTTON_COOLDOWN);\n}\n\n// Handles next button click\nexport function handleNext(instance) {\n  const { state } = instance;\n  if (state.isAnimating) return;\n\n  const targetIndex = calculateNextIndex(instance);\n  scrollToItem(instance, targetIndex);\n}\n\n// Handles previous button click\nexport function handlePrev(instance) {\n  const { state } = instance;\n  if (state.isAnimating) return;\n\n  const targetIndex = calculatePrevIndex(instance);\n  scrollToItem(instance, targetIndex);\n}\n\n// Sets up ResizeObserver to handle responsive behavior\nexport function setupResizeObserver(instance) {\n  const { container, track } = instance;\n  const { TIMING } = CONFIG;\n\n  // Create debounced resize handler\n  const debouncedResize = debounce(() => {\n    // Skip if container is hidden (offsetParent === null)\n    if (container.offsetParent === null) return;\n\n    // Recalculate everything and update UI\n    calculateDimensions(instance);\n    detectActiveItem(instance);\n    updateButtonStates(instance);\n  }, TIMING.DEBOUNCE_RESIZE);\n\n  // Store debounced handler for cleanup\n  instance.debouncedResizeHandler = debouncedResize;\n\n  // Create ResizeObserver instance\n  const resizeObserver = new ResizeObserver(() => {\n    debouncedResize();\n  });\n\n  // Observe container and track only (not items for performance)\n  resizeObserver.observe(container);\n  resizeObserver.observe(track);\n\n  // Store observer on instance for cleanup\n  instance.resizeObserver = resizeObserver;\n}\n\n// Sets up pagination dots if any exist in the container\nexport function setupPagination(instance) {\n  const { dots: existingDots, container, items, id } = instance;\n  const { CLASSES } = CONFIG;\n\n  // Skip if no dots exist\n  if (!existingDots || existingDots.length === 0) return;\n\n  // Remove previously bound handlers before rebuilding dots\n  if (instance.boundDotHandlers) {\n    instance.boundDotHandlers.forEach(({ dot, handler }) => {\n      dot.removeEventListener('click', handler);\n    });\n  }\n\n  // Initialize handler storage\n  instance.boundDotHandlers = [];\n\n  const totalSlides = calculateTotalSlides(items);\n\n  // Converts any provided dot into a semantic button for accessibility\n  const normalizeDotElement = (dot) => {\n    if (dot.tagName && dot.tagName.toLowerCase() === 'button') {\n      return dot;\n    }\n\n    const button = document.createElement('button');\n\n    [...dot.attributes].forEach((attribute) => {\n      button.setAttribute(attribute.name, attribute.value);\n    });\n\n    while (dot.firstChild) {\n      button.appendChild(dot.firstChild);\n    }\n\n    dot.replaceWith(button);\n    return button;\n  };\n\n  // Use first dot as template\n  const templateDot = normalizeDotElement(existingDots[0]);\n  const allDots = [templateDot];\n\n  // Normalize remaining existing dots\n  for (let i = 1; i < existingDots.length; i++) {\n    allDots.push(normalizeDotElement(existingDots[i]));\n  }\n\n  // Get parent from first dot for appending clones\n  const dotsParent = templateDot.parentElement;\n\n  // Clone template to match total slides\n  while (allDots.length < totalSlides) {\n    const duplicate = templateDot.cloneNode(true);\n    dotsParent.appendChild(duplicate);\n    allDots.push(duplicate);\n  }\n\n  // Remove excess dots\n  while (allDots.length > totalSlides) {\n    const removed = allDots.pop();\n    removed.remove();\n  }\n\n  // Prepare each dot with attributes, aria-label, and click handler\n  const preparedDots = [];\n  allDots.forEach((dot, index) => {\n    dot.setAttribute('type', 'button');\n\n    // Remove any pre-existing active class so scripted state controls visuals\n    dot.classList.remove(CLASSES.DOT_ACTIVE);\n\n    // Add accessible label\n    dot.setAttribute(\n      'aria-label',\n      `Go to slide ${index + 1} of ${totalSlides}`\n    );\n\n    // Bind click handler with autoplay pause\n    const handler = () => {\n      if (instance.state.isAutoplaying && !instance.state.isPaused) {\n        pauseAutoplay(instance, 'user');\n      }\n      instance.goTo(index);\n    };\n    dot.addEventListener('click', handler);\n    instance.boundDotHandlers.push({ dot, handler });\n    preparedDots.push(dot);\n  });\n\n  // Update dots reference on instance\n  instance.dots = preparedDots;\n\n  // Set initial active state\n  updatePagination(instance);\n}\n\n// Updates pagination dots to reflect current active item\nexport function updatePagination(instance) {\n  const { dots, container, items, state } = instance;\n  const { CLASSES, SELECTORS } = CONFIG;\n  const { currentIndex } = state;\n\n  // Update each dot's active state and aria-current\n  if (dots && dots.length > 0) {\n    dots.forEach((dot, index) => {\n      const isActive = index === currentIndex;\n      dot.classList.toggle(CLASSES.DOT_ACTIVE, isActive);\n\n      if (isActive) {\n        dot.setAttribute('aria-current', 'true');\n      } else {\n        dot.removeAttribute('aria-current');\n      }\n    });\n  }\n\n  // Inject text content for pagination display elements (silent skip if not found)\n  const currentEl = container.querySelector(SELECTORS.PAGINATION_CURRENT);\n  if (currentEl) {\n    currentEl.textContent = currentIndex + 1;\n  }\n\n  const totalEl = container.querySelector(SELECTORS.PAGINATION_TOTAL);\n  if (totalEl) {\n    totalEl.textContent = items.length;\n  }\n}\n\n// Batches DOM updates using requestAnimationFrame for better performance\nexport function updateUI(instance) {\n  const { rafPending } = instance;\n\n  // Avoid scheduling multiple RAF callbacks\n  if (rafPending) return;\n\n  instance.rafPending = true;\n  requestAnimationFrame(() => {\n    updateActiveClasses(instance);\n    updateButtonStates(instance);\n    updatePagination(instance);\n    updateCSSProperties(instance);\n    instance.rafPending = false;\n  });\n}\n","// Keyboard navigation support\n\nimport { CONFIG } from './config.js';\nimport { pauseAutoplay } from './autoplay.js';\n\n// Applies the active class to the current item and removes it from others\nexport function updateActiveClasses(instance) {\n  const { items, state } = instance;\n  const { CLASSES } = CONFIG;\n  const { currentIndex } = state;\n\n  items.forEach((item, index) => {\n    item.classList.toggle(CLASSES.ACTIVE, index === currentIndex);\n  });\n}\n\n// Sets up keyboard event listeners for navigation\nexport function setupKeyboardNavigation(instance, handlePrev, handleNext) {\n  const { container } = instance;\n\n  // Make container focusable if not already\n  if (!container.hasAttribute('tabindex')) {\n    container.setAttribute('tabindex', '0');\n  }\n\n  // Create and store bound handler\n  const handleKeydown = (event) => {\n    // Only handle keys if focus is on container or its children\n    if (!container.contains(event.target)) {\n      return;\n    }\n\n    // Handle navigation keys\n    switch (event.key) {\n      case 'ArrowLeft':\n        event.preventDefault();\n        if (instance.state.isAutoplaying && !instance.state.isPaused) {\n          pauseAutoplay(instance, 'keyboard');\n        }\n        handlePrev(instance);\n        break;\n\n      case 'ArrowRight':\n        event.preventDefault();\n        if (instance.state.isAutoplaying && !instance.state.isPaused) {\n          pauseAutoplay(instance, 'keyboard');\n        }\n        handleNext(instance);\n        break;\n\n      case 'Home':\n        event.preventDefault();\n        if (instance.state.isAutoplaying && !instance.state.isPaused) {\n          pauseAutoplay(instance, 'keyboard');\n        }\n        instance.goTo(0);\n        break;\n\n      case 'End':\n        event.preventDefault();\n        if (instance.state.isAutoplaying && !instance.state.isPaused) {\n          pauseAutoplay(instance, 'keyboard');\n        }\n        instance.goTo(instance.items.length - 1);\n        break;\n    }\n  };\n\n  // Store handler for cleanup\n  instance.boundHandlers.keyboard = handleKeydown;\n\n  // Attach listener to container\n  container.addEventListener('keydown', handleKeydown);\n}\n","// Main Carousel class and core functionality\n\nimport { CONFIG } from './config.js';\nimport {\n  generateUniqueId,\n  parseConfig,\n  prefersReducedMotion,\n  emit,\n  calculateDimensions,\n  updateCSSProperties,\n} from './utils.js';\nimport {\n  detectActiveItem,\n  handleScroll,\n  scrollToItem,\n  handleNext,\n  handlePrev,\n  setupResizeObserver,\n  setupPagination,\n  updateUI,\n} from './navigation.js';\nimport { setupKeyboardNavigation } from './keyboard.js';\nimport {\n  setupAutoplay,\n  startAutoplay,\n  pauseAutoplay,\n  cleanupAutoplay,\n} from './autoplay.js';\n\n// Finds and validates all required and optional elements within the carousel container\nfunction findElements(instance) {\n  const { container, id } = instance;\n  const { SELECTORS } = CONFIG;\n\n  // Find required track element\n  const track = container.querySelector(SELECTORS.TRACK);\n  if (!track) {\n    console.warn(\n      `Carousel ${id}: Track element not found. Expected element with data-carousel=\"track\".`\n    );\n    return false;\n  }\n\n  // Find required item elements\n  const items = [...container.querySelectorAll(SELECTORS.ITEM)];\n  if (items.length === 0) {\n    console.warn(\n      `Carousel ${id}: No items found. Expected at least one element with data-carousel=\"item\".`\n    );\n    return false;\n  }\n\n  // Find optional navigation buttons (no warning if missing)\n  const prevBtn = container.querySelector(SELECTORS.PREV_BTN);\n  const nextBtn = container.querySelector(SELECTORS.NEXT_BTN);\n\n  // Find optional pagination dots (can be anywhere in container)\n  const dots = [...container.querySelectorAll(SELECTORS.DOT)];\n\n  // Find optional play-pause button\n  const playPauseBtn = container.querySelector(SELECTORS.PLAY_PAUSE_BTN);\n\n  // Add data-carousel-id for easier debugging in devtools\n  container.setAttribute('data-carousel-id', id);\n\n  // Store all element references on the instance\n  Object.assign(instance, {\n    track,\n    items,\n    prevBtn,\n    nextBtn,\n    dots,\n    playPauseBtn,\n  });\n\n  return true;\n}\n\n// Attaches event listeners for user interactions\nfunction attachEventListeners(instance) {\n  const { track, prevBtn, nextBtn, id } = instance;\n\n  // Create bound handlers and store them for later removal\n  instance.boundHandlers = {\n    scroll: () => handleScroll(instance),\n    prev: () => {\n      if (instance.state.isAutoplaying && !instance.state.isPaused) {\n        pauseAutoplay(instance, 'user');\n      }\n      handlePrev(instance);\n    },\n    next: () => {\n      if (instance.state.isAutoplaying && !instance.state.isPaused) {\n        pauseAutoplay(instance, 'user');\n      }\n      handleNext(instance);\n    },\n  };\n\n  // Attach scroll listener with passive flag for better performance\n  track.addEventListener('scroll', instance.boundHandlers.scroll, {\n    passive: true,\n  });\n\n  // Attach button listeners if buttons exist\n  if (prevBtn) {\n    prevBtn.addEventListener('click', instance.boundHandlers.prev);\n  }\n  if (nextBtn) {\n    nextBtn.addEventListener('click', instance.boundHandlers.next);\n  }\n\n  // Attach play-pause button handler\n  if (instance.playPauseBtn) {\n    instance.boundHandlers.playPause = () => {\n      if (instance.state.isAutoplaying && !instance.state.isPaused) {\n        instance.pause();\n      } else {\n        instance.play();\n      }\n    };\n    instance.playPauseBtn.addEventListener('click', instance.boundHandlers.playPause);\n  }\n}\n\n// Cleans up all event listeners, observers, and references\nfunction cleanup(instance) {\n  const { prevBtn, nextBtn, track, container } = instance;\n\n  // Clean up autoplay before removing other listeners\n  cleanupAutoplay(instance);\n\n  if (instance.playPauseBtn && instance.boundHandlers?.playPause) {\n    instance.playPauseBtn.removeEventListener('click', instance.boundHandlers.playPause);\n  }\n\n  // Remove event listeners using stored bound handlers\n  if (instance.boundHandlers) {\n    track.removeEventListener('scroll', instance.boundHandlers.scroll);\n\n    if (prevBtn) {\n      prevBtn.removeEventListener('click', instance.boundHandlers.prev);\n    }\n    if (nextBtn) {\n      nextBtn.removeEventListener('click', instance.boundHandlers.next);\n    }\n\n    // Remove keyboard listener if it exists\n    if (instance.boundHandlers.keyboard) {\n      container.removeEventListener('keydown', instance.boundHandlers.keyboard);\n    }\n  }\n\n  // Remove pagination dot event listeners\n  if (instance.boundDotHandlers) {\n    instance.boundDotHandlers.forEach(({ dot, handler }) => {\n      dot.removeEventListener('click', handler);\n    });\n  }\n\n  // Disconnect ResizeObserver\n  if (instance.resizeObserver) {\n    instance.resizeObserver.disconnect();\n    instance.resizeObserver = null;\n  }\n\n  // Clear all instance properties to help garbage collection\n  Object.keys(instance).forEach((key) => {\n    instance[key] = null;\n  });\n}\n\n// Initializes the carousel instance\nfunction init(instance) {\n  const { container, config } = instance;\n  const { CLASSES, CSS_VARS } = CONFIG;\n\n  // Find and validate elements first\n  const elementsFound = findElements(instance);\n  if (!elementsFound) {\n    return false;\n  }\n\n  // Calculate initial dimensions\n  calculateDimensions(instance);\n\n  // Set initial CSS custom properties before first paint\n  updateCSSProperties(instance);\n\n  // Attach event listeners\n  attachEventListeners(instance);\n\n  // Set up responsive behavior\n  setupResizeObserver(instance);\n\n  // Set up pagination if dots exist\n  setupPagination(instance);\n\n  // Set up keyboard navigation if enabled\n  if (config.keyboard) {\n    setupKeyboardNavigation(instance, handlePrev, handleNext);\n  }\n\n  // Set up autoplay if enabled and reduced motion is not preferred\n  if (prefersReducedMotion()) {\n    container.classList.add(CLASSES.REDUCED_MOTION);\n  }\n  if (config.autoplay && !prefersReducedMotion()) {\n    container.style.setProperty(CSS_VARS.AUTOPLAY_DURATION, config.autoplayDuration + 'ms');\n    setupAutoplay(instance);\n    startAutoplay(instance);\n  }\n\n  // Set initial UI state\n  updateUI(instance);\n\n  return true;\n}\n\n// Main Carousel class\nexport class Carousel {\n  constructor(container) {\n    const id = generateUniqueId();\n    const config = parseConfig(container);\n\n    // Initialize state object with all tracking properties\n    const state = {\n      currentIndex: 0,\n      isScrolling: false,\n      isAnimating: false,\n      itemPositions: [],\n      gap: 0,\n      containerWidth: 0,\n      scrollWidth: 0,\n      startInset: 0,\n      endInset: 0,\n      hasEmittedStart: false,\n      hasEmittedEnd: false,\n      isAutoplaying: false,\n      isPaused: false,\n      autoplayStartTime: null,\n      autoplayElapsed: 0,\n      autoplayPausedOnIndex: null,\n    };\n\n    // Store core properties on instance\n    Object.assign(this, {\n      container,\n      id,\n      config,\n      state,\n      events: new Map(),\n      rafPending: false,\n      boundHandlers: null,\n      debouncedScrollHandler: null,\n      autoplay: null,\n    });\n\n    // Initialize the carousel\n    const initialized = init(this);\n    if (!initialized) {\n      console.warn(\n        `Carousel ${id}: Initialization failed due to missing required elements.`\n      );\n    }\n  }\n\n  // Navigates to the next item\n  next() {\n    handleNext(this);\n    return this;\n  }\n\n  // Navigates to the previous item\n  prev() {\n    handlePrev(this);\n    return this;\n  }\n\n  // Navigates to a specific item by index\n  goTo(index) {\n    const { items } = this;\n    if (index < 0 || index >= items.length) {\n      console.warn(\n        `Carousel ${this.id}: Invalid index ${index}. Must be between 0 and ${\n          items.length - 1\n        }.`\n      );\n      return this;\n    }\n    // Reset autoplay timer when autoplay is running (not paused)\n    if (this.state.isAutoplaying && !this.state.isPaused) {\n      this.state.autoplayStartTime = performance.now();\n    }\n    scrollToItem(this, index);\n    return this;\n  }\n\n  // Starts or resumes autoplay\n  play() {\n    const { CSS_VARS } = CONFIG;\n    if (prefersReducedMotion()) return this;\n    if (!this.autoplay) setupAutoplay(this);\n    this.container.style.setProperty(CSS_VARS.AUTOPLAY_DURATION, this.config.autoplayDuration + 'ms');\n    this.autoplay.pausedByUser = false;\n    startAutoplay(this);\n    return this;\n  }\n\n  // Pauses autoplay with sticky user-pause\n  pause() {\n    pauseAutoplay(this, 'user');\n    return this;\n  }\n\n  // Returns the current active item index\n  getActiveIndex() {\n    return this.state.currentIndex;\n  }\n\n  // Manually recalculates dimensions and updates UI\n  refresh() {\n    calculateDimensions(this);\n    detectActiveItem(this);\n    updateUI(this);\n    return this;\n  }\n\n  // Destroys the carousel instance and cleans up all resources\n  destroy() {\n    cleanup(this);\n    return null;\n  }\n\n  // Subscribes to a carousel event\n  on(event, callback) {\n    const { events } = this;\n    if (!events.has(event)) {\n      events.set(event, []);\n    }\n    events.get(event).push(callback);\n    return this;\n  }\n\n  // Unsubscribes from a carousel event\n  off(event, callback) {\n    const { events } = this;\n    if (!events.has(event)) return this;\n\n    const callbacks = events.get(event);\n    const index = callbacks.indexOf(callback);\n    if (index > -1) {\n      callbacks.splice(index, 1);\n    }\n    return this;\n  }\n\n  // Static method for manual initialization\n  static init(container) {\n    if (typeof container === 'string') {\n      container = document.querySelector(container);\n    }\n    if (!container) {\n      throw new Error('Carousel.init(): Container element not found');\n    }\n    return new Carousel(container);\n  }\n}\n","// Entry point for the carousel library\n\nimport { Carousel } from './core.js';\nimport { SELECTORS } from './config.js';\n\n// Global registry to store all initialized carousel instances\nconst instances = new Map();\n\n// Auto-initializes all carousels on the page when DOM is ready\nfunction autoInit() {\n  const containers = document.querySelectorAll(SELECTORS.CONTAINER);\n\n  containers.forEach((container) => {\n    try {\n      const carousel = new Carousel(container);\n      if (carousel.id) {\n        instances.set(carousel.id, carousel);\n      }\n    } catch (error) {\n      console.warn('Carousel auto-initialization failed:', error);\n    }\n  });\n\n  if (instances.size > 0) {\n    // Carousel instances initialized\n  }\n}\n\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\nif (typeof window !== 'undefined') {\n  window.Carousel = Carousel;\n  window.CarouselInstances = instances;\n}\n"],"names":["SELECTORS","CONTAINER","TRACK","ITEM","PREV_BTN","NEXT_BTN","DOT","PAGINATION_CURRENT","PAGINATION_TOTAL","PLAY_PAUSE_BTN","CLASSES","SCROLLING","DISABLED","ACTIVE","ANIMATING","SNAP_DISABLED","DOT_ACTIVE","AUTOPLAY_ACTIVE","AUTOPLAY_PAUSED","REDUCED_MOTION","DEFAULTS","CSS_VARS","INDEX","TOTAL","PROGRESS","AUTOPLAY_PROGRESS","AUTOPLAY_DURATION","EVENTS","CONFIG","TIMING","DEBOUNCE_RESIZE","DEBOUNCE_SCROLL","BUTTON_COOLDOWN","SNAP_DISABLE_DURATION","TOLERANCE","EDGE_DETECTION","idCounter","prefersReducedMotion","window","matchMedia","matches","debounce","func","wait","timeout","args","clearTimeout","setTimeout","emit","instance","event","data","events","container","has","get","forEach","callback","call","type","target","customEvent","CustomEvent","detail","carousel","bubbles","dispatchEvent","calculateDimensions","track","items","state","config","trackStyle","getComputedStyle","parseOffset","value","specified","parsed","parseFloat","Number","isNaN","gap","columnGap","paddingInlineStart","paddingLeft","paddingInlineEnd","paddingRight","scrollPaddingInlineStart","scrollPaddingLeft","scrollPaddingInlineEnd","scrollPaddingRight","startInset","endInset","containerWidth","clientWidth","scrollWidth","trackRect","getBoundingClientRect","itemPositions","map","item","index","rect","itemStyle","marginStartValue","scrollMarginInlineStart","scrollMarginLeft","marginEndValue","scrollMarginInlineEnd","scrollMarginRight","marginStart","marginEnd","left","scrollLeft","width","center","right","Object","assign","snapAlign","align","updateCSSProperties","currentIndex","style","setProperty","length","maxScroll","progress","Math","min","max","runAutoplayTick","autoplay","isAutoplaying","isPaused","elapsed","performance","now","autoplayStartTime","autoplayDuration","toString","dots","dot","next","rafId","requestAnimationFrame","canResume","isVisible","pausedByHover","pausedByFocus","pausedByUser","setupAutoplay","observer","IntersectionObserver","entries","entry","isIntersecting","resumeAutoplay","pauseAutoplay","threshold","observe","autoplayPauseHover","handleMouseEnter","handleMouseLeave","addEventListener","autoplayPauseFocus","handleFocusIn","handleFocusOut","e","contains","relatedTarget","startAutoplay","classList","add","remove","playPauseBtn","setAttribute","reason","cancelAnimationFrame","autoplayElapsed","autoplayPausedOnIndex","sameSlide","detectActiveItem","activeIndex","options","referencePoint","offsets","calculateReferencePoint","closestIndex","minDistance","Infinity","itemPoint","getItemAlignmentPoint","distance","abs","findActiveIndex","updateUI","updateButtonStates","prevBtn","nextBtn","atStart","atEnd","loop","disabled","toggle","hasEmittedStart","hasEmittedEnd","scrollToItem","targetItem","isAnimating","scrollIntoView","behavior","block","inline","console","warn","id","handleNext","targetIndex","scrollBy","targetLeft","i","findNextPageIndex","nextIndex","calculateNextIndex","handlePrev","findPrevPageIndex","prevIndex","calculatePrevIndex","setupPagination","existingDots","boundDotHandlers","handler","removeEventListener","totalSlides","Array","isArray","calculateTotalSlides","normalizeDotElement","tagName","toLowerCase","button","document","createElement","attributes","attribute","name","firstChild","appendChild","replaceWith","templateDot","allDots","push","dotsParent","parentElement","duplicate","cloneNode","pop","preparedDots","goTo","updatePagination","isActive","removeAttribute","currentEl","querySelector","textContent","totalEl","rafPending","updateActiveClasses","attachEventListeners","boundHandlers","scroll","debouncedScrollHandler","handleScroll","prev","passive","playPause","pause","play","cleanup","disconnect","cleanupAutoplay","keyboard","resizeObserver","keys","key","init","elementsFound","querySelectorAll","findElements","debouncedResize","offsetParent","debouncedResizeHandler","ResizeObserver","setupResizeObserver","hasAttribute","handleKeydown","preventDefault","setupKeyboardNavigation","Carousel","constructor","getAttribute","parseInt","parseConfig","this","isScrolling","Map","getActiveIndex","refresh","destroy","on","set","off","callbacks","indexOf","splice","Error","instances","autoInit","error","size","readyState","CarouselInstances"],"mappings":"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"}