{"version":3,"file":"carousel.min.js","sources":["../../../packages/carousel/src/config.js","../../../packages/carousel/src/utils.js","../../../packages/carousel/src/navigation.js","../../../packages/carousel/src/keyboard.js","../../../packages/carousel/src/autoplay.js","../../../packages/carousel/src/core.js","../../../packages/carousel/src/carousel.js"],"sourcesContent":["// Builds a presence-based selector with opt-out support\nconst sel = (attr) => `[${attr}]:not([${attr}=\"false\"])`;\n\nexport const SELECTOR_ATTRS = {\n  // Structural\n  CONTAINER:          'data-carousel-container',\n  TRACK:              'data-carousel-track',\n  ITEM:               'data-carousel-item',\n  PREV_BTN:           'data-carousel-prev',\n  NEXT_BTN:           'data-carousel-next',\n  MARKER:             'data-carousel-marker',\n  COUNTER_CURRENT:    'data-carousel-counter-current',\n  COUNTER_TOTAL:      'data-carousel-counter-total',\n  PLAY_PAUSE_BTN:     'data-carousel-play-pause',\n  RESTART_BTN:        'data-carousel-restart',\n  // Boolean config\n  KEYBOARD:              'data-carousel-keyboard',\n  LOOP:                  'data-carousel-loop',\n  AUTOPLAY:              'data-carousel-autoplay',\n  AUTOPLAY_PAUSE_HOVER:  'data-carousel-autoplay-pause-hover',\n  AUTOPLAY_PAUSE_FOCUS:  'data-carousel-autoplay-pause-focus',\n};\n\nexport const SELECTORS = Object.fromEntries(\n  Object.entries(SELECTOR_ATTRS).map(([k, v]) => [k, sel(v)])\n);\n\n// CSS classes applied to elements\nexport const CLASSES = {\n  SCROLLING: 'carousel-scrolling', // Applied to track while scrolling is active\n  DISABLED: 'carousel-nav-disabled', // Applied to nav buttons when at start/end edges\n  ACTIVE: 'carousel-item-active', // Applied to the current active item\n  VISIBLE: 'carousel-item-visible', // Applied to items currently in viewport (reserved for future use)\n  MARKER_ACTIVE: 'carousel-marker-active', // Applied to the current active marker\n  PLAYING: 'carousel-playing',\n  AT_END: 'carousel-at-end',\n  REDUCED_MOTION: 'carousel-reduced-motion',\n};\n\nexport const DEFAULTS = {\n  ALIGN: 'start',\n  KEYBOARD: false,\n  SCROLL_BY: 'item',\n  LOOP: false,\n  AUTOPLAY: false,\n  AUTOPLAY_DURATION: 5000,\n  AUTOPLAY_PAUSE_HOVER: false,\n  AUTOPLAY_PAUSE_FOCUS: true,\n};\n\n// Timing constants in milliseconds\nexport const TIMING = {\n  DEBOUNCE_RESIZE: 150,\n  DEBOUNCE_SCROLL: 100,\n};\n\n// Pixel tolerance for fractional pixel calculations\nexport const TOLERANCE = {\n  EDGE_DETECTION: 1,\n  ACTIVE_DETECTION: 2,\n};\n\n// CSS custom property names\nexport const CSS_VARS = {\n  INDEX: '--carousel-index',\n  TOTAL: '--carousel-total',\n  PROGRESS: '--carousel-progress',\n  AUTOPLAY_PROGRESS: '--carousel-autoplay-progress',\n  AUTOPLAY_DURATION: '--carousel-autoplay-duration',\n};\n\n// Event names for CustomEvents\nexport const EVENTS = {\n  SNAPCHANGE: 'snapchange',\n  SCROLL: 'scroll',\n  REACH_START: 'reach-start',\n  REACH_END: 'reach-end',\n  AUTOPLAY_START: 'autoplay-start',\n  AUTOPLAY_STOP: 'autoplay-stop',\n};\n\n// Data attribute names for value-based configuration\nexport const ATTRIBUTES = {\n  ALIGN: 'data-carousel-align',\n  SCROLL_BY: 'data-carousel-scroll-by',\n  AUTOPLAY_DURATION: 'data-carousel-autoplay-duration',\n};\n\nexport const CONFIG = {\n  SELECTORS,\n  CLASSES,\n  DEFAULTS,\n  TIMING,\n  TOLERANCE,\n  CSS_VARS,\n  EVENTS,\n  ATTRIBUTES,\n};\n","// Pure utility functions for the carousel library\n\nimport { DEFAULTS, CSS_VARS, SELECTORS, SELECTOR_ATTRS, ATTRIBUTES } from './config.js';\n\n// Counter for generating unique carousel IDs\nlet idCounter = 0;\n\n// Generates a unique ID for each carousel instance\nexport function generateUniqueId() {\n  idCounter += 1;\n  return `carousel-${idCounter}`;\n}\n\n// Parses configuration from data attributes on the container element\nexport function parseConfig(container) {\n  const align = container.getAttribute(ATTRIBUTES.ALIGN) || DEFAULTS.ALIGN;\n  const keyboard = container.matches(SELECTORS.KEYBOARD);\n  const loop = container.matches(SELECTORS.LOOP);\n  const scrollBy = container.getAttribute(ATTRIBUTES.SCROLL_BY) || DEFAULTS.SCROLL_BY;\n  const autoplay = container.matches(SELECTORS.AUTOPLAY);\n  const autoplayDuration = parseInt(container.getAttribute(ATTRIBUTES.AUTOPLAY_DURATION), 10) || DEFAULTS.AUTOPLAY_DURATION;\n  const autoplayPauseHover = container.matches(SELECTORS.AUTOPLAY_PAUSE_HOVER);\n  const autoplayPauseFocus = container.getAttribute(SELECTOR_ATTRS.AUTOPLAY_PAUSE_FOCUS) !== 'false';\n\n  return { align, keyboard, loop, scrollBy, autoplay, autoplayDuration, autoplayPauseHover, autoplayPauseFocus };\n}\n\n// Checks if the user prefers reduced motion\nexport function prefersReducedMotion() {\n  return window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n}\n\n// Creates a debounced version of a function\nexport function debounce(func, wait) {\n  let timeout;\n\n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// Calculates the reference point for snap alignment detection\nfunction calculateReferencePoint(\n  scrollLeft,\n  containerWidth,\n  snapAlign,\n  offsets = {}\n) {\n  const { startInset = 0, endInset = 0 } = offsets;\n  switch (snapAlign) {\n    case 'center':\n      return scrollLeft + containerWidth / 2 + (startInset - endInset) / 2;\n    case 'end':\n      return scrollLeft + containerWidth - endInset;\n    default: // 'start'\n      return scrollLeft + startInset;\n  }\n}\n\n// Gets the alignment point for a specific item based on snap alignment\nfunction getItemAlignmentPoint(item, snapAlign) {\n  const marginStart = item.marginStart || 0;\n  const marginEnd = item.marginEnd || 0;\n  switch (snapAlign) {\n    case 'center':\n      return item.center + (marginEnd - marginStart) / 2;\n    case 'end':\n      return item.right + marginEnd;\n    default: // 'start'\n      return item.left - marginStart;\n  }\n}\n\n// Finds the index of the active item based on scroll position\nexport function findActiveIndex(\n  itemPositions,\n  scrollLeft,\n  containerWidth,\n  snapAlign,\n  options = {}\n) {\n  const { startInset = 0, endInset = 0 } = options;\n  const referencePoint = calculateReferencePoint(\n    scrollLeft,\n    containerWidth,\n    snapAlign,\n    { startInset, endInset }\n  );\n\n  let closestIndex = 0;\n  let minDistance = Infinity;\n  const distances = [];\n\n  itemPositions.forEach((item, index) => {\n    const itemPoint = getItemAlignmentPoint(item, snapAlign);\n    const distance = Math.abs(itemPoint - referencePoint);\n\n    distances.push({ index, itemPoint, distance });\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestIndex = index;\n    }\n  });\n\n  return closestIndex;\n}\n\n// Finds the target index when scrolling forward by one container width\nexport function findNextPageIndex(instance) {\n  const { track, state, config } = instance;\n  const { itemPositions, containerWidth, maxReachableIndex } = state;\n  const targetLeft = track.scrollLeft + containerWidth;\n\n  for (let i = state.currentIndex + 1; i < itemPositions.length; i++) {\n    if (i > maxReachableIndex) return config.loop ? 0 : maxReachableIndex;\n    if (itemPositions[i].left >= targetLeft) return i;\n  }\n\n  // Near the end\n  return config.loop ? 0 : maxReachableIndex;\n}\n\n// Finds the target index when scrolling backward by one container width\nexport function findPrevPageIndex(instance) {\n  const { track, state, config } = instance;\n  const { itemPositions, containerWidth, maxReachableIndex } = state;\n  const targetLeft = track.scrollLeft - containerWidth;\n\n  for (let i = state.currentIndex - 1; i >= 0; i--) {\n    if (itemPositions[i].left <= targetLeft) return i;\n  }\n\n  // Near the start\n  return config.loop ? maxReachableIndex : 0;\n}\n\n// Returns the total number of navigable positions (snap groups)\nexport function calculateTotalPositions(instance) {\n  return instance.state.totalPositions;\n}\n\n// Emits custom events both through the instance event system and as DOM events\nexport function emit(instance, event, data = {}) {\n  const { events, container } = instance;\n\n  // Call registered callbacks via instance.on()\n  if (events.has(event)) {\n    const callbacks = events.get(event);\n    callbacks.forEach((callback) => {\n      callback.call(instance, {\n        type: event,\n        target: instance,\n        ...data,\n      });\n    });\n  }\n\n  // Dispatch native DOM custom event for addEventListener compatibility\n  const customEvent = new CustomEvent(`carousel:${event}`, {\n    detail: { carousel: instance, ...data },\n    bubbles: true,\n  });\n  container.dispatchEvent(customEvent);\n}\n\n// Calculates and stores all dimensional measurements for the carousel\nexport function calculateDimensions(instance) {\n  const { track, items, state, config } = instance;\n\n  // Get computed styles to read CSS properties\n  const trackStyle = getComputedStyle(track);\n\n  const parseOffset = (value) => {\n    if (!value || value === 'auto') {\n      return { value: 0, specified: false };\n    }\n    const parsed = parseFloat(value);\n    if (Number.isNaN(parsed)) {\n      return { value: 0, specified: false };\n    }\n    return { value: parsed, specified: true };\n  };\n\n  // Read gap from CSS (try both gap and column-gap for compatibility)\n  const gap = parseFloat(trackStyle.gap || trackStyle.columnGap) || 0;\n\n  const paddingInlineStart = parseOffset(\n    trackStyle.paddingInlineStart || trackStyle.paddingLeft\n  );\n  const paddingInlineEnd = parseOffset(\n    trackStyle.paddingInlineEnd || trackStyle.paddingRight\n  );\n  const scrollPaddingInlineStart = parseOffset(\n    trackStyle.scrollPaddingInlineStart || trackStyle.scrollPaddingLeft\n  );\n  const scrollPaddingInlineEnd = parseOffset(\n    trackStyle.scrollPaddingInlineEnd || trackStyle.scrollPaddingRight\n  );\n\n  const startInset = scrollPaddingInlineStart.specified\n    ? scrollPaddingInlineStart.value\n    : paddingInlineStart.value;\n  const endInset = scrollPaddingInlineEnd.specified\n    ? scrollPaddingInlineEnd.value\n    : paddingInlineEnd.value;\n\n  // Measure container and scroll dimensions\n  const containerWidth = track.clientWidth;\n  const scrollWidth = track.scrollWidth;\n\n  // Calculate basic position data for active item detection\n  const trackRect = track.getBoundingClientRect();\n  const itemPositions = items.map((item, index) => {\n    const rect = item.getBoundingClientRect();\n    const itemStyle = getComputedStyle(item);\n\n    // Read scroll-margin for detection calculations\n    const marginStartValue = parseFloat(\n      itemStyle.scrollMarginInlineStart || itemStyle.scrollMarginLeft\n    );\n    const marginEndValue = parseFloat(\n      itemStyle.scrollMarginInlineEnd || itemStyle.scrollMarginRight\n    );\n    const marginStart = Number.isNaN(marginStartValue) ? 0 : marginStartValue;\n    const marginEnd = Number.isNaN(marginEndValue) ? 0 : marginEndValue;\n\n    // Calculate left position relative to track, accounting for current scroll\n    const left = rect.left - trackRect.left + track.scrollLeft;\n    const width = rect.width;\n\n    return {\n      index,\n      left,\n      width,\n      center: left + width / 2,\n      right: left + width,\n      marginStart,\n      marginEnd,\n    };\n  });\n\n  // Update state with measurements needed for detection\n  Object.assign(state, {\n    gap,\n    containerWidth,\n    scrollWidth,\n    itemPositions,\n    startInset,\n    endInset,\n  });\n\n  // Store snap alignment on instance for reference\n  instance.snapAlign = config.align;\n\n  // Compute the highest index findActiveIndex can detect at max scroll\n  const maxScroll = scrollWidth - containerWidth;\n  let maxReachableIndex;\n  if (maxScroll <= 0) {\n    maxReachableIndex = 0;\n  } else {\n    maxReachableIndex = findActiveIndex(\n      itemPositions, maxScroll, containerWidth, config.align,\n      { startInset, endInset }\n    );\n  }\n\n  const totalPositions = maxReachableIndex + 1;\n\n  Object.assign(state, {\n    maxReachableIndex,\n    totalPositions,\n  });\n}\n\n// Updates CSS custom properties on the carousel container\nexport function updateCSSProperties(instance) {\n  const { container, track, items, state } = instance;\n  const { currentIndex, scrollWidth, containerWidth } = state;\n\n  // Set one-based index for display friendliness\n  container.style.setProperty(CSS_VARS.INDEX, currentIndex + 1);\n\n  // Set total navigable positions (snap groups)\n  container.style.setProperty(CSS_VARS.TOTAL, state.totalPositions);\n\n  // Calculate progress (0-1) based on scroll position\n  const maxScroll = scrollWidth - containerWidth;\n  const scrollLeft = track.scrollLeft;\n  const progress =\n    maxScroll > 0 ? Math.min(1, Math.max(0, scrollLeft / maxScroll)) : 0;\n  container.style.setProperty(CSS_VARS.PROGRESS, progress);\n}\n\n// Logs a console warning when loop/autoplay is enabled with unreachable items\nexport function warnUnreachableItems(instance) {\n  const { config, state, items, id } = instance;\n  if (state.maxReachableIndex >= items.length - 1) return;\n  if (!config.loop && !config.autoplay) return;\n\n  const unreachableCount = items.length - 1 - state.maxReachableIndex;\n  const features = [config.loop && 'loop', config.autoplay && 'autoplay'].filter(Boolean).join(' and ');\n  console.warn(\n    `Carousel ${id}: ${unreachableCount} item(s) (indices ${state.maxReachableIndex + 1}-${items.length - 1}) ` +\n    `share the same scroll position as item ${state.maxReachableIndex} and cannot be individually activated. ` +\n    `${features} will cycle through ${state.totalPositions} positions instead of ${items.length}. ` +\n    `To make every item individually reachable, use wider items or add padding-inline-end to the track.`\n  );\n}\n","// Navigation and marker functionality\n\nimport { CONFIG } from './config.js';\nimport {\n  findActiveIndex,\n  findNextPageIndex,\n  findPrevPageIndex,\n  debounce,\n  calculateTotalPositions,\n  emit,\n  calculateDimensions,\n  updateCSSProperties,\n} from './utils.js';\nimport { updateActiveClasses } from './keyboard.js';\n\n// Detects which item is currently active based on scroll position\nexport function detectActiveItem(instance) {\n  const { track, state, snapAlign } = instance;\n  const { itemPositions, currentIndex, startInset = 0, endInset = 0 } = state;\n\n  // Find the active index using scroll position\n  const scrollLeft = track.scrollLeft;\n  const activeIndex = findActiveIndex(\n    itemPositions,\n    scrollLeft,\n    state.containerWidth,\n    snapAlign,\n    {\n      startInset,\n      endInset,\n    }\n  );\n\n  // Only update if the active item has changed\n  if (activeIndex !== currentIndex) {\n    state.currentIndex = activeIndex;\n    updateUI(instance);\n    emit(instance, 'snapchange', { index: activeIndex });\n  }\n}\n\n// Updates the disabled state of navigation buttons based on current index\nexport function updateButtonStates(instance) {\n  const { track, prevBtn, nextBtn, state, config } = instance;\n  const { CLASSES, TOLERANCE } = CONFIG;\n\n  // Edge detection still uses physical scroll position (for reach-start/reach-end events)\n  const scrollLeft = track.scrollLeft;\n  const maxScroll = state.scrollWidth - state.containerWidth;\n  const atStart = scrollLeft <= TOLERANCE.EDGE_DETECTION;\n  const atEnd = scrollLeft >= maxScroll - TOLERANCE.EDGE_DETECTION;\n\n  // Button disabled state uses index (not scroll position)\n  const atFirstPosition = state.currentIndex <= 0;\n  const atLastPosition = state.currentIndex >= state.maxReachableIndex;\n\n  if (config.loop) {\n    if (prevBtn) { prevBtn.classList.remove(CLASSES.DISABLED); prevBtn.disabled = false; }\n    if (nextBtn) { nextBtn.classList.remove(CLASSES.DISABLED); nextBtn.disabled = false; }\n  } else {\n    if (prevBtn) {\n      prevBtn.classList.toggle(CLASSES.DISABLED, atFirstPosition);\n      prevBtn.disabled = atFirstPosition;\n    }\n    if (nextBtn) {\n      nextBtn.classList.toggle(CLASSES.DISABLED, atLastPosition);\n      nextBtn.disabled = atLastPosition;\n    }\n  }\n\n  // Toggle at-end class for autoplay-configured carousels\n  if (instance.autoplay && !config.loop) {\n    instance.container.classList.toggle(CLASSES.AT_END, atLastPosition && !state.isAutoplaying);\n  } else {\n    instance.container.classList.remove(CLASSES.AT_END);\n  }\n\n  // Edge events still fire based on physical scroll position\n  if (atStart && !state.hasEmittedStart) {\n    emit(instance, 'reach-start');\n    state.hasEmittedStart = true;\n  } else if (!atStart) {\n    state.hasEmittedStart = false;\n  }\n\n  if (atEnd && !state.hasEmittedEnd) {\n    emit(instance, 'reach-end');\n    state.hasEmittedEnd = true;\n  } else if (!atEnd) {\n    state.hasEmittedEnd = false;\n  }\n}\n\n// Handles scroll events on the track\nexport function handleScroll(instance) {\n  const { track } = instance;\n  const { CLASSES, TIMING } = CONFIG;\n\n  track.classList.add(CLASSES.SCROLLING);\n  emit(instance, 'scroll', { scrollLeft: track.scrollLeft });\n\n  if (!instance.debouncedScrollHandler) {\n    instance.debouncedScrollHandler = debounce(() => {\n      detectActiveItem(instance);\n      updateButtonStates(instance);\n      track.classList.remove(CLASSES.SCROLLING);\n    }, TIMING.DEBOUNCE_SCROLL);\n  }\n  instance.debouncedScrollHandler();\n}\n\n// Calculates the index of the next item for navigation\nexport function calculateNextIndex(instance) {\n  const { state, config } = instance;\n\n  if (config.scrollBy === 'page') return findNextPageIndex(instance);\n\n  const nextIndex = state.currentIndex + 1;\n  if (nextIndex > state.maxReachableIndex) {\n    return config.loop ? 0 : state.maxReachableIndex;\n  }\n  return nextIndex;\n}\n\n// Calculates the index of the previous item for navigation\nexport function calculatePrevIndex(instance) {\n  const { state, config } = instance;\n\n  if (config.scrollBy === 'page') return findPrevPageIndex(instance);\n\n  const prevIndex = state.currentIndex - 1;\n  if (prevIndex < 0) {\n    return config.loop ? state.maxReachableIndex : 0;\n  }\n  return prevIndex;\n}\n\n// Scrolls to a specific item index with smooth animation\nexport function scrollToItem(instance, index) {\n  const { items, snapAlign } = instance;\n  const targetItem = items[index];\n  if (!targetItem) {\n    console.warn(`Carousel ${instance.id}: No item found at index ${index}`);\n    return;\n  }\n\n  targetItem.scrollIntoView({\n    behavior: 'smooth',\n    block: 'nearest',\n    inline: snapAlign,\n  });\n}\n\n// Handles next button click\nexport function handleNext(instance) {\n  const { state } = instance;\n\n  const targetIndex = calculateNextIndex(instance);\n  if (targetIndex === state.currentIndex) return;\n\n  // Set index directly (decoupled from scroll detection)\n  state.currentIndex = targetIndex;\n  updateUI(instance);\n  emit(instance, 'snapchange', { index: targetIndex });\n\n  // Scroll as visual effect\n  scrollToItem(instance, targetIndex);\n}\n\n// Handles previous button click\nexport function handlePrev(instance) {\n  const { state } = instance;\n\n  const targetIndex = calculatePrevIndex(instance);\n  if (targetIndex === state.currentIndex) return;\n\n  state.currentIndex = targetIndex;\n  updateUI(instance);\n  emit(instance, 'snapchange', { index: targetIndex });\n\n  scrollToItem(instance, targetIndex);\n}\n\n// Sets up ResizeObserver to handle responsive behavior\nexport function setupResizeObserver(instance) {\n  const { container, track } = instance;\n  const { TIMING } = CONFIG;\n\n  const debouncedResize = debounce(() => {\n    if (container.offsetParent === null) return;\n\n    const prevTotalPositions = instance.state.totalPositions;\n\n    calculateDimensions(instance);\n\n    // If the number of snap positions changed, re-setup markers\n    if (instance.state.totalPositions !== prevTotalPositions) {\n      setupMarkers(instance);\n    }\n\n    // Clamp currentIndex to new maxReachableIndex\n    if (instance.state.currentIndex > instance.state.maxReachableIndex) {\n      instance.state.currentIndex = instance.state.maxReachableIndex;\n    }\n\n    detectActiveItem(instance);\n    updateButtonStates(instance);\n  }, TIMING.DEBOUNCE_RESIZE);\n\n  instance.debouncedResizeHandler = debouncedResize;\n\n  const resizeObserver = new ResizeObserver(() => {\n    debouncedResize();\n  });\n\n  resizeObserver.observe(container);\n  resizeObserver.observe(track);\n  instance.resizeObserver = resizeObserver;\n}\n\n// Sets up markers if any exist in the container\nexport function setupMarkers(instance) {\n  const { markers: existingMarkers, container, items, id } = instance;\n  const { CLASSES } = CONFIG;\n\n  // Skip if no markers exist\n  if (!existingMarkers || existingMarkers.length === 0) return;\n\n  // Remove previously bound handlers before rebuilding markers\n  if (instance.boundMarkerHandlers) {\n    instance.boundMarkerHandlers.forEach(({ marker, handler }) => {\n      marker.removeEventListener('click', handler);\n    });\n  }\n\n  // Initialize handler storage\n  instance.boundMarkerHandlers = [];\n\n  const totalPositions = calculateTotalPositions(instance);\n\n  // Converts any provided marker into a semantic button for accessibility\n  const normalizeMarkerElement = (marker) => {\n    if (marker.tagName && marker.tagName.toLowerCase() === 'button') {\n      return marker;\n    }\n\n    const button = document.createElement('button');\n\n    [...marker.attributes].forEach((attribute) => {\n      button.setAttribute(attribute.name, attribute.value);\n    });\n\n    while (marker.firstChild) {\n      button.appendChild(marker.firstChild);\n    }\n\n    marker.replaceWith(button);\n    return button;\n  };\n\n  // Use first marker as template\n  const templateMarker = normalizeMarkerElement(existingMarkers[0]);\n  const allMarkers = [templateMarker];\n\n  // Normalize remaining existing markers\n  for (let i = 1; i < existingMarkers.length; i++) {\n    allMarkers.push(normalizeMarkerElement(existingMarkers[i]));\n  }\n\n  // Get parent from first marker for appending clones\n  const markerGroup = templateMarker.parentElement;\n  instance.markerGroup = markerGroup;\n\n  // Set semantic roles on marker group (only if not already set by author)\n  if (!markerGroup.hasAttribute('role')) {\n    markerGroup.setAttribute('role', 'tablist');\n  }\n\n  // Clone template to match total positions\n  while (allMarkers.length < totalPositions) {\n    const duplicate = templateMarker.cloneNode(true);\n    markerGroup.appendChild(duplicate);\n    allMarkers.push(duplicate);\n  }\n\n  // Remove excess markers\n  while (allMarkers.length > totalPositions) {\n    const removed = allMarkers.pop();\n    removed.remove();\n  }\n\n  // Prepare each marker with attributes, aria-label, and click handler\n  const preparedMarkers = [];\n  allMarkers.forEach((marker, index) => {\n    marker.setAttribute('type', 'button');\n\n    // Set semantic role on marker (only if not already set by author)\n    if (!marker.hasAttribute('role')) {\n      marker.setAttribute('role', 'tab');\n    }\n\n    // Remove any pre-existing active class so scripted state controls visuals\n    marker.classList.remove(CLASSES.MARKER_ACTIVE);\n\n    // Add accessible label\n    marker.setAttribute(\n      'aria-label',\n      `Scroll to item ${index + 1} of ${totalPositions}`\n    );\n\n    // Bind click handler (goTo handles autoplay stop)\n    const handler = () => {\n      instance.goTo(index);\n    };\n    marker.addEventListener('click', handler);\n    instance.boundMarkerHandlers.push({ marker, handler });\n    preparedMarkers.push(marker);\n  });\n\n  // Update markers reference on instance\n  instance.markers = preparedMarkers;\n\n  // Set up roving tabindex keyboard handler on marker group\n  setupMarkerKeyboard(instance);\n\n  // Set initial active state\n  updateMarkers(instance);\n}\n\n// Sets up delegated keyboard handler on marker group for roving tabindex\nfunction setupMarkerKeyboard(instance) {\n  const { markers, markerGroup, config } = instance;\n  if (!markers || markers.length <= 1) return;\n\n  // Remove existing handler if present (idempotent for rebuilds)\n  if (instance.boundHandlers.markerKeydown && markerGroup) {\n    markerGroup.removeEventListener('keydown', instance.boundHandlers.markerKeydown);\n  }\n\n  const handler = (event) => {\n    const currentMarkerIndex = instance.markers.indexOf(event.target);\n    if (currentMarkerIndex === -1) return;\n\n    const lastIndex = instance.markers.length - 1;\n    let targetIndex = null;\n\n    switch (event.key) {\n      case 'ArrowRight':\n        targetIndex = currentMarkerIndex < lastIndex\n          ? currentMarkerIndex + 1\n          : (config.loop ? 0 : lastIndex);\n        break;\n      case 'ArrowLeft':\n        targetIndex = currentMarkerIndex > 0\n          ? currentMarkerIndex - 1\n          : (config.loop ? lastIndex : 0);\n        break;\n      case 'Home':\n        targetIndex = 0;\n        break;\n      case 'End':\n        targetIndex = lastIndex;\n        break;\n      default:\n        return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (targetIndex !== currentMarkerIndex) {\n      instance.goTo(targetIndex);\n      instance.markers[targetIndex].focus();\n    }\n  };\n\n  markerGroup.addEventListener('keydown', handler);\n  instance.boundHandlers.markerKeydown = handler;\n}\n\n// Updates markers to reflect current active item\nexport function updateMarkers(instance) {\n  const { markers, container, state } = instance;\n  const { CLASSES, SELECTORS } = CONFIG;\n  const { currentIndex } = state;\n\n  if (markers && markers.length > 0) {\n    markers.forEach((marker, index) => {\n      const isActive = index === currentIndex;\n      marker.classList.toggle(CLASSES.MARKER_ACTIVE, isActive);\n      marker.setAttribute('tabindex', isActive ? '0' : '-1');\n\n      marker.setAttribute('aria-selected', isActive ? 'true' : 'false');\n    });\n\n    // Move focus to active marker only when user is already interacting with markers\n    if (instance.markerGroup?.contains(document.activeElement)) {\n      markers[currentIndex].focus();\n    }\n  }\n\n  const currentEl = container.querySelector(SELECTORS.COUNTER_CURRENT);\n  if (currentEl) {\n    currentEl.textContent = currentIndex + 1;\n  }\n\n  const totalEl = container.querySelector(SELECTORS.COUNTER_TOTAL);\n  if (totalEl) {\n    totalEl.textContent = state.totalPositions;\n  }\n}\n\n// Batches DOM updates using requestAnimationFrame for better performance\nexport function updateUI(instance) {\n  const { rafPending } = instance;\n\n  // Avoid scheduling multiple RAF callbacks\n  if (rafPending) return;\n\n  instance.rafPending = true;\n  requestAnimationFrame(() => {\n    updateActiveClasses(instance);\n    updateButtonStates(instance);\n    updateMarkers(instance);\n    updateCSSProperties(instance);\n    if (instance.liveRegion) {\n      instance.liveRegion.textContent = `Item ${instance.state.currentIndex + 1} of ${instance.state.totalPositions}`;\n    }\n    instance.rafPending = false;\n  });\n}\n","// Keyboard navigation support\n\nimport { CONFIG } from './config.js';\n\n// Applies the active class to the current item and removes it from others\nexport function updateActiveClasses(instance) {\n  const { items, state } = instance;\n  const { CLASSES } = CONFIG;\n  const { currentIndex } = state;\n\n  items.forEach((item, index) => {\n    item.classList.toggle(CLASSES.ACTIVE, index === currentIndex);\n  });\n}\n\n// Sets up keyboard event listeners for navigation\nexport function setupKeyboardNavigation(instance) {\n  const { container } = instance;\n\n  // Make container focusable if not already\n  if (!container.hasAttribute('tabindex')) {\n    container.setAttribute('tabindex', '0');\n  }\n\n  // Create and store bound handler\n  const handleKeydown = (event) => {\n    // Only handle keys if focus is on container or its children\n    if (!container.contains(event.target)) {\n      return;\n    }\n\n    // Handle navigation keys\n    switch (event.key) {\n      case 'ArrowLeft':\n        event.preventDefault();\n        instance.prev();\n        break;\n\n      case 'ArrowRight':\n        event.preventDefault();\n        instance.next();\n        break;\n\n      case 'Home':\n        event.preventDefault();\n        instance.goTo(0);\n        break;\n\n      case 'End':\n        event.preventDefault();\n        instance.goTo(instance.state.maxReachableIndex);\n        break;\n    }\n  };\n\n  // Store handler for cleanup\n  instance.boundHandlers.keyboard = handleKeydown;\n\n  // Attach listener to container\n  container.addEventListener('keydown', handleKeydown);\n}\n","// Autoplay behavior for carousel: timer, progress updates, pause/resume\n\nimport { CLASSES, CSS_VARS, EVENTS } from './config.js';\nimport { emit } from './utils.js';\n\n// RAF tick loop for autoplay progress\nfunction runAutoplayTick(instance) {\n  const { state, config, autoplay } = instance;\n\n  if (!state.isAutoplaying || state.isPaused) return;\n\n  const elapsed = performance.now() - state.autoplayStartTime;\n  const progress = Math.min(elapsed / config.autoplayDuration, 1);\n\n  // Update progress on container\n  instance.container.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, progress.toString());\n\n  // Update progress on active marker, reset inactive markers\n  if (instance.markers?.length > 0) {\n    instance.markers.forEach((marker, index) => {\n      if (index === state.currentIndex) {\n        marker.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, progress.toString());\n      } else {\n        marker.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, '0');\n      }\n    });\n  }\n\n  if (progress >= 1) {\n    const atEnd = state.currentIndex >= state.maxReachableIndex && !instance.config.loop;\n    if (atEnd) {\n      stopAutoplay(instance, 'complete');\n      autoplay.onStop?.();\n      return;\n    }\n    autoplay.advanceFn(instance);\n    state.autoplayStartTime = performance.now();\n  }\n\n  autoplay.rafId = requestAnimationFrame(() => runAutoplayTick(instance));\n}\n\n// Checks if autoplay can resume from a temporary pause\nfunction canResume(instance) {\n  const { autoplay, state } = instance;\n  return (\n    state.isAutoplaying &&\n    autoplay.isVisible &&\n    !autoplay.pausedByHover &&\n    !autoplay.pausedByFocus\n  );\n}\n\n// Sets up autoplay with IntersectionObserver and pause handlers\nexport function setupAutoplay(instance, advanceFn) {\n  const { container, config } = instance;\n\n  instance.autoplay = {\n    rafId: null,\n    observer: null,\n    advanceFn,\n    isVisible: true,\n    pausedByHover: false,\n    pausedByFocus: false,\n  };\n\n  // Initialize autoplay state fields on the instance\n  Object.assign(instance.state, {\n    isAutoplaying: false,\n    isPaused: false,\n    autoplayStartTime: null,\n    autoplayElapsed: 0,\n    autoplayPausedOnIndex: null,\n  });\n\n  // IntersectionObserver to pause when out of viewport\n  instance.autoplay.observer = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        instance.autoplay.isVisible = entry.isIntersecting;\n        if (!entry.isIntersecting) {\n          pauseAutoplay(instance, 'visibility');\n        } else if (canResume(instance)) {\n          resumeAutoplay(instance);\n        }\n      });\n    },\n    { threshold: 0.5 }\n  );\n  instance.autoplay.observer.observe(container);\n\n  // Hover pause handlers (target the track, not container)\n  if (config.autoplayPauseHover) {\n    instance.autoplay.handleMouseEnter = () => {\n      instance.autoplay.pausedByHover = true;\n      pauseAutoplay(instance, 'hover');\n    };\n    instance.autoplay.handleMouseLeave = () => {\n      instance.autoplay.pausedByHover = false;\n      if (canResume(instance)) {\n        resumeAutoplay(instance);\n      }\n    };\n    instance.track.addEventListener('mouseenter', instance.autoplay.handleMouseEnter);\n    instance.track.addEventListener('mouseleave', instance.autoplay.handleMouseLeave);\n  }\n\n  // Focus pause handlers (target the track, not container)\n  if (config.autoplayPauseFocus) {\n    instance.autoplay.handleFocusIn = () => {\n      instance.autoplay.pausedByFocus = true;\n      pauseAutoplay(instance, 'focus');\n    };\n    instance.autoplay.handleFocusOut = (e) => {\n      // Only resume if focus leaves the track entirely\n      if (!instance.track.contains(e.relatedTarget)) {\n        instance.autoplay.pausedByFocus = false;\n        if (canResume(instance)) {\n          resumeAutoplay(instance);\n        }\n      }\n    };\n    instance.track.addEventListener('focusin', instance.autoplay.handleFocusIn);\n    instance.track.addEventListener('focusout', instance.autoplay.handleFocusOut);\n  }\n}\n\n// Starts autoplay timer with RAF progress updates\nexport function startAutoplay(instance) {\n  const { container, state } = instance;\n\n  // Nothing to cycle through â€” skip autoplay entirely\n  if (state.totalPositions <= 1) return;\n\n  state.isAutoplaying = true;\n  state.isPaused = false;\n  state.autoplayStartTime = performance.now();\n\n  container.classList.add(CLASSES.PLAYING);\n\n  // Update play/pause button\n  if (instance.playPauseBtn) {\n    instance.playPauseBtn.setAttribute('aria-label', 'Stop autoplay');\n  }\n\n  // Suppress live region announcements during autoplay\n  if (instance.liveRegion) {\n    instance.liveRegion.setAttribute('aria-live', 'off');\n  }\n\n  emit(instance, EVENTS.AUTOPLAY_START, { index: state.currentIndex });\n\n  instance.autoplay.rafId = requestAnimationFrame(() =>\n    runAutoplayTick(instance)\n  );\n}\n\n// Temporarily pauses autoplay (for hover, focus, visibility)\nexport function pauseAutoplay(instance, reason = 'user') {\n  const { state, container } = instance;\n\n  if (!state.isAutoplaying || state.isPaused) return;\n\n  state.isPaused = true;\n\n  // Store elapsed time and active index so we can resume from this point\n  const elapsed = performance.now() - state.autoplayStartTime;\n  const progress = Math.min(elapsed / instance.config.autoplayDuration, 1);\n  state.autoplayElapsed = elapsed;\n  state.autoplayPausedOnIndex = state.currentIndex;\n\n  // Cancel RAF\n  if (instance.autoplay.rafId) {\n    cancelAnimationFrame(instance.autoplay.rafId);\n    instance.autoplay.rafId = null;\n  }\n\n  container.classList.remove(CLASSES.PLAYING);\n\n  // Update play/pause button\n  if (instance.playPauseBtn) {\n    instance.playPauseBtn.setAttribute('aria-label', 'Start autoplay');\n  }\n\n  // Re-enable live region announcements\n  if (instance.liveRegion) {\n    instance.liveRegion.setAttribute('aria-live', 'polite');\n  }\n\n  emit(instance, EVENTS.AUTOPLAY_STOP, {\n    index: state.currentIndex,\n    progress,\n    reason,\n  });\n}\n\n// Resumes autoplay from where it was paused\nexport function resumeAutoplay(instance) {\n  const { state, container } = instance;\n\n  if (!state.isAutoplaying || !state.isPaused) return;\n  if (!canResume(instance)) return;\n\n  state.isPaused = false;\n  // Resume from stored elapsed time only if still on the same item, otherwise reset\n  const sameItem = state.autoplayPausedOnIndex === state.currentIndex;\n  state.autoplayStartTime = sameItem\n    ? performance.now() - (state.autoplayElapsed || 0)\n    : performance.now();\n\n  container.classList.add(CLASSES.PLAYING);\n\n  // Update play/pause button\n  if (instance.playPauseBtn) {\n    instance.playPauseBtn.setAttribute('aria-label', 'Stop autoplay');\n  }\n\n  // Suppress live region announcements during autoplay\n  if (instance.liveRegion) {\n    instance.liveRegion.setAttribute('aria-live', 'off');\n  }\n\n  emit(instance, EVENTS.AUTOPLAY_START, { index: state.currentIndex });\n\n  instance.autoplay.rafId = requestAnimationFrame(() =>\n    runAutoplayTick(instance)\n  );\n}\n\n// Stops autoplay completely\nexport function stopAutoplay(instance, reason = 'user') {\n  const { state, container } = instance;\n\n  if (!state.isAutoplaying) return;\n\n  // Compute progress before resetting\n  const elapsed = performance.now() - state.autoplayStartTime;\n  const progress = Math.min(elapsed / instance.config.autoplayDuration, 1);\n\n  state.isAutoplaying = false;\n  state.isPaused = false;\n\n  if (instance.autoplay?.rafId) {\n    cancelAnimationFrame(instance.autoplay.rafId);\n    instance.autoplay.rafId = null;\n  }\n\n  container.classList.remove(CLASSES.PLAYING);\n\n  // Update play/pause button\n  if (instance.playPauseBtn) {\n    instance.playPauseBtn.setAttribute('aria-label', 'Start autoplay');\n  }\n\n  // Re-enable live region announcements\n  if (instance.liveRegion) {\n    instance.liveRegion.setAttribute('aria-live', 'polite');\n  }\n\n  emit(instance, EVENTS.AUTOPLAY_STOP, {\n    index: state.currentIndex,\n    progress,\n    reason,\n  });\n\n  // Reset progress on container\n  container.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, '0');\n\n  // Reset progress on all markers\n  if (instance.markers?.length > 0) {\n    instance.markers.forEach((marker) => {\n      marker.style.setProperty(CSS_VARS.AUTOPLAY_PROGRESS, '0');\n    });\n  }\n}\n\n// Cleans up autoplay listeners and observer\nexport function cleanupAutoplay(instance) {\n  const { config, autoplay } = instance;\n\n  if (!autoplay) return;\n\n  // Cancel RAF\n  if (autoplay.rafId) {\n    cancelAnimationFrame(autoplay.rafId);\n  }\n\n  // Disconnect IntersectionObserver\n  if (autoplay.observer) {\n    autoplay.observer.disconnect();\n  }\n\n  // Remove hover listeners from track\n  if (config.autoplayPauseHover && autoplay.handleMouseEnter) {\n    instance.track.removeEventListener('mouseenter', autoplay.handleMouseEnter);\n    instance.track.removeEventListener('mouseleave', autoplay.handleMouseLeave);\n  }\n\n  // Remove focus listeners from track\n  if (config.autoplayPauseFocus && autoplay.handleFocusIn) {\n    instance.track.removeEventListener('focusin', autoplay.handleFocusIn);\n    instance.track.removeEventListener('focusout', autoplay.handleFocusOut);\n  }\n\n  instance.autoplay = null;\n}\n","// Main Carousel class and core functionality\n\nimport { CONFIG } from './config.js';\nimport {\n  generateUniqueId,\n  parseConfig,\n  prefersReducedMotion,\n  emit,\n  calculateDimensions,\n  updateCSSProperties,\n  warnUnreachableItems,\n} from './utils.js';\nimport {\n  detectActiveItem,\n  handleScroll,\n  scrollToItem,\n  handleNext,\n  handlePrev,\n  setupResizeObserver,\n  setupMarkers,\n  updateUI,\n} from './navigation.js';\nimport { setupKeyboardNavigation } from './keyboard.js';\nimport {\n  setupAutoplay,\n  startAutoplay,\n  stopAutoplay,\n  cleanupAutoplay,\n} from './autoplay.js';\n\n// Finds and validates all required and optional elements within the carousel container\nfunction findElements(instance) {\n  const { container, id } = instance;\n  const { SELECTORS } = CONFIG;\n\n  // Find required track element (legacy backwards compat)\n  const track = container.querySelector(`${SELECTORS.TRACK}, [data-carousel=\"track\"]`);\n  if (!track) {\n    console.warn(\n      `Carousel ${id}: Track element not found. Expected element with data-carousel-track.`\n    );\n    return false;\n  }\n\n  // Find required item elements (legacy backwards compat)\n  const items = [...container.querySelectorAll(`${SELECTORS.ITEM}, [data-carousel=\"item\"]`)];\n  if (items.length === 0) {\n    console.warn(\n      `Carousel ${id}: No items found. Expected at least one element with data-carousel-item.`\n    );\n    return false;\n  }\n\n  // Find optional navigation buttons (legacy backwards compat)\n  const prevBtn = container.querySelector(`${SELECTORS.PREV_BTN}, [data-carousel=\"prev\"]`);\n  const nextBtn = container.querySelector(`${SELECTORS.NEXT_BTN}, [data-carousel=\"next\"]`);\n\n  // Find optional markers (can be anywhere in container)\n  const markers = [...container.querySelectorAll(SELECTORS.MARKER)];\n\n  // Find autoplay-specific elements only when autoplay is configured\n  let playPauseBtn = null;\n  let restartBtn = null;\n\n  if (instance.config.autoplay) {\n    playPauseBtn = container.querySelector(SELECTORS.PLAY_PAUSE_BTN);\n    restartBtn = container.querySelector(SELECTORS.RESTART_BTN);\n  } else {\n    if (container.querySelector(SELECTORS.PLAY_PAUSE_BTN)) {\n      console.warn(\n        `Carousel ${id}: Play/pause button found but autoplay is not enabled. Add data-carousel-autoplay to the container.`\n      );\n    }\n    if (container.querySelector(SELECTORS.RESTART_BTN)) {\n      console.warn(\n        `Carousel ${id}: Restart button found but autoplay is not enabled. Add data-carousel-autoplay to the container.`\n      );\n    }\n  }\n\n  // Add data-carousel-id for easier debugging in devtools\n  container.setAttribute('data-carousel-id', id);\n\n  // Store all element references on the instance\n  Object.assign(instance, {\n    track,\n    items,\n    prevBtn,\n    nextBtn,\n    markers,\n    playPauseBtn,\n    restartBtn,\n  });\n\n  return true;\n}\n\n// Attaches event listeners for user interactions\nfunction attachEventListeners(instance) {\n  const { track, prevBtn, nextBtn } = instance;\n\n  // Create bound handlers and store them for later removal\n  instance.boundHandlers = {\n    scroll: () => {\n      handleScroll(instance);\n    },\n    prev: () => instance.prev(),\n    next: () => instance.next(),\n  };\n\n  // Attach scroll listener with passive flag for better performance\n  track.addEventListener('scroll', instance.boundHandlers.scroll, {\n    passive: true,\n  });\n\n  // Attach button listeners if buttons exist\n  if (prevBtn) {\n    prevBtn.addEventListener('click', instance.boundHandlers.prev);\n  }\n  if (nextBtn) {\n    nextBtn.addEventListener('click', instance.boundHandlers.next);\n  }\n\n  // Autoplay-specific listeners (only when autoplay is configured)\n  if (instance.config.autoplay) {\n    // Stop autoplay on direct user interaction with the track\n    instance.boundHandlers.trackPointerDown = () => {\n      if (instance.state.isAutoplaying) stopAutoplay(instance, 'user');\n    };\n    instance.boundHandlers.trackWheel = () => {\n      if (instance.state.isAutoplaying) stopAutoplay(instance, 'user');\n    };\n    track.addEventListener('pointerdown', instance.boundHandlers.trackPointerDown);\n    track.addEventListener('wheel', instance.boundHandlers.trackWheel, { passive: true });\n\n    if (instance.playPauseBtn) {\n      instance.boundHandlers.playPause = () => {\n        if (instance.state.isAutoplaying) {\n          stopAutoplay(instance, 'user');\n        } else {\n          instance.play();\n        }\n      };\n      instance.playPauseBtn.addEventListener('click', instance.boundHandlers.playPause);\n    }\n\n    if (instance.restartBtn) {\n      instance.boundHandlers.restart = () => {\n        instance.goTo(0);\n        instance.play();\n      };\n      instance.restartBtn.addEventListener('click', instance.boundHandlers.restart);\n    }\n  }\n}\n\n// Cleans up all event listeners, observers, and references\nfunction cleanup(instance) {\n  const { prevBtn, nextBtn, track, container } = instance;\n\n  // Clean up autoplay before removing other listeners\n  cleanupAutoplay(instance);\n\n  if (instance.playPauseBtn && instance.boundHandlers?.playPause) {\n    instance.playPauseBtn.removeEventListener('click', instance.boundHandlers.playPause);\n  }\n\n  if (instance.restartBtn && instance.boundHandlers?.restart) {\n    instance.restartBtn.removeEventListener('click', instance.boundHandlers.restart);\n  }\n\n  // Remove event listeners using stored bound handlers\n  if (instance.boundHandlers) {\n    track.removeEventListener('scroll', instance.boundHandlers.scroll);\n\n    if (instance.boundHandlers.trackPointerDown) {\n      track.removeEventListener('pointerdown', instance.boundHandlers.trackPointerDown);\n    }\n    if (instance.boundHandlers.trackWheel) {\n      track.removeEventListener('wheel', instance.boundHandlers.trackWheel);\n    }\n\n    if (prevBtn) {\n      prevBtn.removeEventListener('click', instance.boundHandlers.prev);\n    }\n    if (nextBtn) {\n      nextBtn.removeEventListener('click', instance.boundHandlers.next);\n    }\n\n    // Remove keyboard listener if it exists\n    if (instance.boundHandlers.keyboard) {\n      container.removeEventListener('keydown', instance.boundHandlers.keyboard);\n    }\n\n    // Remove marker keyboard listener if it exists\n    if (instance.boundHandlers.markerKeydown && instance.markerGroup) {\n      instance.markerGroup.removeEventListener('keydown', instance.boundHandlers.markerKeydown);\n    }\n  }\n\n  // Remove marker event listeners\n  if (instance.boundMarkerHandlers) {\n    instance.boundMarkerHandlers.forEach(({ marker, handler }) => {\n      marker.removeEventListener('click', handler);\n    });\n  }\n\n  // Remove inline styles from track and items\n  if (instance.track) {\n    instance.track.style.removeProperty('scroll-behavior');\n  }\n  if (instance.items) {\n    instance.items.forEach((item) => item.style.removeProperty('scroll-snap-align'));\n  }\n\n  // Remove live region element\n  instance.liveRegion?.remove();\n\n  // Disconnect ResizeObserver\n  if (instance.resizeObserver) {\n    instance.resizeObserver.disconnect();\n    instance.resizeObserver = null;\n  }\n\n  // Clear all instance properties to help garbage collection\n  Object.keys(instance).forEach((key) => {\n    instance[key] = null;\n  });\n}\n\n// Initializes the carousel instance\nfunction init(instance) {\n  const { container, config } = instance;\n  const { CLASSES, CSS_VARS } = CONFIG;\n\n  // Find and validate elements first\n  const elementsFound = findElements(instance);\n  if (!elementsFound) {\n    return false;\n  }\n\n  // Force instant scrolling when user prefers reduced motion\n  if (prefersReducedMotion()) {\n    instance.track.style.scrollBehavior = 'auto';\n  }\n\n  // Set semantic roles on track and items (only if not already set by author)\n  if (!instance.track.hasAttribute('role')) {\n    instance.track.setAttribute('role', 'list');\n  }\n  instance.items.forEach((item) => {\n    if (!item.hasAttribute('role')) {\n      item.setAttribute('role', 'listitem');\n    }\n    item.style.scrollSnapAlign = config.align;\n  });\n\n  // Add accessible label to restart button\n  if (instance.restartBtn && !instance.restartBtn.hasAttribute('aria-label')) {\n    instance.restartBtn.setAttribute('aria-label', 'Restart autoplay');\n  }\n\n  // Calculate initial dimensions\n  calculateDimensions(instance);\n\n  // Warn if loop/autoplay enabled with unreachable items\n  warnUnreachableItems(instance);\n\n  // Set initial CSS custom properties before first paint\n  updateCSSProperties(instance);\n\n  // Create live region for screen reader announcements\n  const liveRegion = document.createElement('div');\n  Object.assign(liveRegion.style, {\n    position: 'absolute',\n    width: '1px',\n    height: '1px',\n    padding: '0',\n    margin: '-1px',\n    overflow: 'hidden',\n    clip: 'rect(0,0,0,0)',\n    whiteSpace: 'nowrap',\n    border: '0',\n  });\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.setAttribute('aria-atomic', 'true');\n  container.appendChild(liveRegion);\n  instance.liveRegion = liveRegion;\n\n  // Attach event listeners\n  attachEventListeners(instance);\n\n  // Set up responsive behavior\n  setupResizeObserver(instance);\n\n  // Set up markers if they exist\n  setupMarkers(instance);\n\n  // Set up keyboard navigation if enabled\n  if (config.keyboard) {\n    setupKeyboardNavigation(instance);\n  }\n\n  // Set up autoplay if enabled and reduced motion is not preferred\n  if (prefersReducedMotion()) {\n    container.classList.add(CLASSES.REDUCED_MOTION);\n  }\n  if (config.autoplay && !prefersReducedMotion()) {\n    if (instance.state.totalPositions <= 1) {\n      console.warn(\n        `Carousel ${id}: Autoplay has nothing to cycle through (only 1 item). Add more items or remove data-carousel-autoplay.`\n      );\n    }\n    container.style.setProperty(CSS_VARS.AUTOPLAY_DURATION, config.autoplayDuration + 'ms');\n    setupAutoplay(instance, handleNext);\n    instance.autoplay.onStop = () => updateUI(instance);\n    startAutoplay(instance);\n  }\n\n  // Set initial UI state\n  updateUI(instance);\n\n  return true;\n}\n\n// Main Carousel class\nexport class Carousel {\n  constructor(container) {\n    const id = generateUniqueId();\n    const config = parseConfig(container);\n\n    // Initialize state object with all tracking properties\n    const state = {\n      currentIndex: 0,\n      itemPositions: [],\n      gap: 0,\n      containerWidth: 0,\n      scrollWidth: 0,\n      startInset: 0,\n      endInset: 0,\n      maxReachableIndex: 0,\n      totalPositions: 0,\n      hasEmittedStart: false,\n      hasEmittedEnd: false,\n    };\n\n    // Store core properties on instance\n    Object.assign(this, {\n      container,\n      id,\n      config,\n      state,\n      events: new Map(),\n      rafPending: false,\n      boundHandlers: null,\n      debouncedScrollHandler: null,\n    });\n\n    // Initialize the carousel\n    const initialized = init(this);\n    if (!initialized) {\n      console.warn(\n        `Carousel ${id}: Initialization failed due to missing required elements.`\n      );\n    }\n  }\n\n  // Navigates to the next item\n  next() {\n    if (this.autoplay) stopAutoplay(this, 'user');\n    handleNext(this);\n    return this;\n  }\n\n  // Navigates to the previous item\n  prev() {\n    if (this.autoplay) stopAutoplay(this, 'user');\n    handlePrev(this);\n    return this;\n  }\n\n  // Navigates to a specific item by index\n  goTo(index) {\n    const { items, state } = this;\n\n    if (index < 0 || index >= items.length) {\n      console.warn(\n        `Carousel ${this.id}: Invalid index ${index}. Must be between 0 and ${\n          items.length - 1\n        }.`\n      );\n      return this;\n    }\n\n    // Clamp to maxReachableIndex (indices beyond it share the last snap position)\n    if (index > state.maxReachableIndex) {\n      index = state.maxReachableIndex;\n    }\n\n    if (this.autoplay) stopAutoplay(this, 'user');\n\n    // Set index directly (decoupled)\n    if (index !== state.currentIndex) {\n      state.currentIndex = index;\n      updateUI(this);\n      emit(this, 'snapchange', { index });\n    }\n\n    // Scroll as visual effect\n    scrollToItem(this, index);\n    return this;\n  }\n\n  // Starts autoplay fresh (always full duration)\n  play() {\n    if (!this.config.autoplay) {\n      console.warn(\n        `Carousel ${this.id}: Autoplay is not enabled. Add data-carousel-autoplay to the container.`\n      );\n      return this;\n    }\n    const { CSS_VARS } = CONFIG;\n    if (prefersReducedMotion()) return this;\n    if (!this.autoplay) {\n      setupAutoplay(this, handleNext);\n      this.autoplay.onStop = () => updateUI(this);\n    }\n    this.container.style.setProperty(CSS_VARS.AUTOPLAY_DURATION, this.config.autoplayDuration + 'ms');\n    startAutoplay(this);\n    return this;\n  }\n\n  // Stops autoplay completely\n  stop() {\n    stopAutoplay(this, 'user');\n    return this;\n  }\n\n  // Returns the current active item index\n  getActiveIndex() {\n    return this.state.currentIndex;\n  }\n\n  // Manually recalculates dimensions and updates UI\n  refresh() {\n    const prevTotalPositions = this.state.totalPositions;\n\n    calculateDimensions(this);\n\n    // Re-setup markers if snap group count changed\n    if (this.state.totalPositions !== prevTotalPositions) {\n      setupMarkers(this);\n    }\n\n    // Clamp currentIndex\n    if (this.state.currentIndex > this.state.maxReachableIndex) {\n      this.state.currentIndex = this.state.maxReachableIndex;\n    }\n\n    detectActiveItem(this);\n    updateUI(this);\n    return this;\n  }\n\n  // Destroys the carousel instance and cleans up all resources\n  destroy() {\n    cleanup(this);\n    return null;\n  }\n\n  // Subscribes to a carousel event\n  on(event, callback) {\n    const { events } = this;\n    if (!events.has(event)) {\n      events.set(event, []);\n    }\n    events.get(event).push(callback);\n    return this;\n  }\n\n  // Unsubscribes from a carousel event\n  off(event, callback) {\n    const { events } = this;\n    if (!events.has(event)) return this;\n\n    const callbacks = events.get(event);\n    const index = callbacks.indexOf(callback);\n    if (index > -1) {\n      callbacks.splice(index, 1);\n    }\n    return this;\n  }\n\n  // Static method for manual initialization\n  static init(container) {\n    if (typeof container === 'string') {\n      container = document.querySelector(container);\n    }\n    if (!container) {\n      throw new Error('Carousel.init(): Container element not found');\n    }\n    return new Carousel(container);\n  }\n}\n","// Entry point for the carousel library\n\nimport { Carousel } from './core.js';\nimport { SELECTORS } from './config.js';\n\n// Global registry to store all initialized carousel instances\nconst instances = new Map();\n\n// Auto-initializes all carousels on the page when DOM is ready\nfunction autoInit() {\n  // Query new attribute, with silent fallback for legacy data-carousel=\"container\"\n  const containers = document.querySelectorAll(\n    `${SELECTORS.CONTAINER}, [data-carousel=\"container\"]`\n  );\n\n  containers.forEach((container) => {\n    try {\n      const carousel = new Carousel(container);\n      if (carousel.id) {\n        instances.set(carousel.id, carousel);\n      }\n    } catch (error) {\n      console.warn('Carousel auto-initialization failed:', error);\n    }\n  });\n\n  if (instances.size > 0) {\n    // Carousel instances initialized\n  }\n}\n\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\nif (typeof window !== 'undefined') {\n  window.Carousel = Carousel;\n  window.CarouselInstances = instances;\n}\n"],"names":["SELECTOR_ATTRS","CONTAINER","TRACK","ITEM","PREV_BTN","NEXT_BTN","MARKER","COUNTER_CURRENT","COUNTER_TOTAL","PLAY_PAUSE_BTN","RESTART_BTN","KEYBOARD","LOOP","AUTOPLAY","AUTOPLAY_PAUSE_HOVER","AUTOPLAY_PAUSE_FOCUS","SELECTORS","Object","fromEntries","entries","map","k","v","attr","CLASSES","SCROLLING","DISABLED","ACTIVE","MARKER_ACTIVE","PLAYING","AT_END","REDUCED_MOTION","DEFAULTS","CSS_VARS","INDEX","TOTAL","PROGRESS","AUTOPLAY_PROGRESS","AUTOPLAY_DURATION","EVENTS","ATTRIBUTES","CONFIG","TIMING","DEBOUNCE_RESIZE","DEBOUNCE_SCROLL","TOLERANCE","EDGE_DETECTION","idCounter","prefersReducedMotion","window","matchMedia","matches","debounce","func","wait","timeout","args","clearTimeout","setTimeout","findActiveIndex","itemPositions","scrollLeft","containerWidth","snapAlign","options","startInset","endInset","referencePoint","offsets","calculateReferencePoint","closestIndex","minDistance","Infinity","forEach","item","index","itemPoint","marginStart","marginEnd","center","right","left","getItemAlignmentPoint","distance","Math","abs","emit","instance","event","data","events","container","has","get","callback","call","type","target","customEvent","CustomEvent","detail","carousel","bubbles","dispatchEvent","calculateDimensions","track","items","state","config","trackStyle","getComputedStyle","parseOffset","value","specified","parsed","parseFloat","Number","isNaN","gap","columnGap","paddingInlineStart","paddingLeft","paddingInlineEnd","paddingRight","scrollPaddingInlineStart","scrollPaddingLeft","scrollPaddingInlineEnd","scrollPaddingRight","clientWidth","scrollWidth","trackRect","getBoundingClientRect","rect","itemStyle","marginStartValue","scrollMarginInlineStart","scrollMarginLeft","marginEndValue","scrollMarginInlineEnd","scrollMarginRight","width","assign","align","maxScroll","maxReachableIndex","totalPositions","updateCSSProperties","currentIndex","style","setProperty","progress","min","max","detectActiveItem","activeIndex","updateUI","updateButtonStates","prevBtn","nextBtn","atStart","atEnd","atFirstPosition","atLastPosition","loop","classList","remove","disabled","toggle","autoplay","isAutoplaying","hasEmittedStart","hasEmittedEnd","scrollToItem","targetItem","scrollIntoView","behavior","block","inline","console","warn","id","handleNext","targetIndex","scrollBy","targetLeft","i","length","findNextPageIndex","nextIndex","calculateNextIndex","setupMarkers","markers","existingMarkers","boundMarkerHandlers","marker","handler","removeEventListener","calculateTotalPositions","normalizeMarkerElement","tagName","toLowerCase","button","document","createElement","attributes","attribute","setAttribute","name","firstChild","appendChild","replaceWith","templateMarker","allMarkers","push","markerGroup","parentElement","hasAttribute","duplicate","cloneNode","pop","preparedMarkers","goTo","addEventListener","boundHandlers","markerKeydown","currentMarkerIndex","indexOf","lastIndex","key","preventDefault","stopPropagation","focus","setupMarkerKeyboard","updateMarkers","isActive","contains","activeElement","currentEl","querySelector","textContent","totalEl","rafPending","requestAnimationFrame","updateActiveClasses","liveRegion","runAutoplayTick","isPaused","elapsed","performance","now","autoplayStartTime","autoplayDuration","toString","stopAutoplay","onStop","advanceFn","rafId","canResume","isVisible","pausedByHover","pausedByFocus","setupAutoplay","observer","autoplayElapsed","autoplayPausedOnIndex","IntersectionObserver","entry","isIntersecting","resumeAutoplay","pauseAutoplay","threshold","observe","autoplayPauseHover","handleMouseEnter","handleMouseLeave","autoplayPauseFocus","handleFocusIn","handleFocusOut","e","relatedTarget","startAutoplay","add","playPauseBtn","reason","cancelAnimationFrame","sameItem","attachEventListeners","scroll","debouncedScrollHandler","handleScroll","prev","next","passive","trackPointerDown","trackWheel","playPause","play","restartBtn","restart","cleanup","disconnect","cleanupAutoplay","keyboard","removeProperty","resizeObserver","keys","init","elementsFound","querySelectorAll","findElements","scrollBehavior","scrollSnapAlign","unreachableCount","features","filter","Boolean","join","warnUnreachableItems","position","height","padding","margin","overflow","clip","whiteSpace","border","debouncedResize","offsetParent","prevTotalPositions","debouncedResizeHandler","ResizeObserver","setupResizeObserver","handleKeydown","setupKeyboardNavigation","Carousel","constructor","getAttribute","parseInt","parseConfig","this","Map","findPrevPageIndex","prevIndex","calculatePrevIndex","handlePrev","stop","getActiveIndex","refresh","destroy","on","set","off","callbacks","splice","Error","instances","autoInit","error","size","readyState","CarouselInstances"],"mappings":"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"}