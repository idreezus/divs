{"version":3,"file":"carousel.min.js","sources":["../../../packages/carousel/src/config.js","../../../packages/carousel/src/utils.js","../../../packages/carousel/src/navigation.js","../../../packages/carousel/src/keyboard.js","../../../packages/carousel/src/core.js","../../../packages/carousel/src/carousel.js"],"sourcesContent":["export const SELECTORS = {\n  CONTAINER: '[data-carousel=\"container\"]',\n  TRACK: '[data-carousel=\"track\"]',\n  ITEM: '[data-carousel=\"item\"]',\n  PREV_BTN: '[data-carousel=\"prev\"]',\n  NEXT_BTN: '[data-carousel=\"next\"]',\n  PAGINATION: '[data-carousel=\"pagination\"]',\n  DOT: '[data-carousel=\"dot\"]',\n};\n\n// CSS classes applied to elements\nexport const CLASSES = {\n  SCROLLING: 'carousel-scrolling', // Applied to track while user or programmatic scroll is active\n  DISABLED: 'carousel-button-disabled', // Applied to buttons when at start/end edges\n  ACTIVE: 'carousel-item-active', // Applied to the current active item\n  VISIBLE: 'carousel-item-visible', // Applied to items currently in viewport (reserved for future use)\n  ANIMATING: 'carousel-animating', // Applied to track during programmatic scroll\n  SNAP_DISABLED: 'carousel-snap-disabled', // Applied to track to temporarily disable scroll-snap during button navigation\n  PAGINATION_ACTIVE: 'carousel-pagination-active', // Applied to the current active pagination dot\n  PAGINATION_AUTO_DOT: 'carousel-auto-pagination-dot', // Applied to the automatically generated pagination dots\n  LIVE_REGION: 'carousel-sr-only', // Applied to the live region for screen readers\n};\n\nexport const DEFAULTS = {\n  ALIGN: 'start',\n  KEYBOARD: false,\n  SCROLL_BY: 'item',\n  LOOP: false,\n};\n\n// Timing constants in milliseconds\nexport const TIMING = {\n  DEBOUNCE_RESIZE: 150,\n  DEBOUNCE_SCROLL: 100,\n  BUTTON_COOLDOWN: 100,\n  SNAP_DISABLE_DURATION: 50,\n};\n\n// Pixel tolerance for fractional pixel calculations\nexport const TOLERANCE = {\n  EDGE_DETECTION: 1,\n  ACTIVE_DETECTION: 2,\n};\n\nexport const CONFIG = {\n  SELECTORS,\n  CLASSES,\n  DEFAULTS,\n  TIMING,\n  TOLERANCE,\n};\n","// Pure utility functions for the carousel library\n\nimport { DEFAULTS } from './config.js';\n\n// Counter for generating unique carousel IDs\nlet idCounter = 0;\n\n// Generates a unique ID for each carousel instance\nexport function generateUniqueId() {\n  idCounter += 1;\n  return `carousel-${idCounter}`;\n}\n\n// Parses configuration from data attributes on the container element\nexport function parseConfig(container) {\n  const align = container.getAttribute('data-carousel-align') || DEFAULTS.ALIGN;\n  const keyboard = container.getAttribute('data-carousel-keyboard') === 'true';\n  const scrollBy =\n    container.getAttribute('data-carousel-scroll-by') || DEFAULTS.SCROLL_BY;\n  const loop = container.getAttribute('data-carousel-loop') === 'true';\n\n  return {\n    align,\n    keyboard,\n    scrollBy,\n    loop,\n  };\n}\n\n// Creates a debounced version of a function\nexport function debounce(func, wait) {\n  let timeout;\n\n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// Calculates the reference point for snap alignment detection\nfunction calculateReferencePoint(\n  scrollLeft,\n  containerWidth,\n  snapAlign,\n  offsets = {}\n) {\n  const { startInset = 0, endInset = 0 } = offsets;\n  switch (snapAlign) {\n    case 'center':\n      return scrollLeft + containerWidth / 2 + (startInset - endInset) / 2;\n    case 'end':\n      return scrollLeft + containerWidth - endInset;\n    default: // 'start'\n      return scrollLeft + startInset;\n  }\n}\n\n// Gets the alignment point for a specific item based on snap alignment\nfunction getItemAlignmentPoint(item, snapAlign) {\n  const marginStart = item.marginStart || 0;\n  const marginEnd = item.marginEnd || 0;\n  switch (snapAlign) {\n    case 'center':\n      return item.center + (marginEnd - marginStart) / 2;\n    case 'end':\n      return item.right + marginEnd;\n    default: // 'start'\n      return item.left - marginStart;\n  }\n}\n\n// Finds the index of the active item based on scroll position\nexport function findActiveIndex(\n  itemPositions,\n  scrollLeft,\n  containerWidth,\n  snapAlign,\n  options = {}\n) {\n  const { startInset = 0, endInset = 0 } = options;\n  const referencePoint = calculateReferencePoint(\n    scrollLeft,\n    containerWidth,\n    snapAlign,\n    { startInset, endInset }\n  );\n\n  let closestIndex = 0;\n  let minDistance = Infinity;\n  const distances = [];\n\n  itemPositions.forEach((item, index) => {\n    const itemPoint = getItemAlignmentPoint(item, snapAlign);\n    const distance = Math.abs(itemPoint - referencePoint);\n\n    distances.push({ index, itemPoint, distance });\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestIndex = index;\n    }\n  });\n\n  console.log('[DEBUG findActiveIndex]', {\n    scrollLeft,\n    containerWidth,\n    snapAlign,\n    referencePoint,\n    startInset,\n    endInset,\n    distances,\n    closestIndex,\n    minDistance,\n  });\n\n  return closestIndex;\n}\n\n// Returns the total number of slides for the provided collection of items\nexport function calculateTotalSlides(items) {\n  if (!Array.isArray(items)) {\n    return 0;\n  }\n\n  return items.length;\n}\n\n// Emits custom events both through the instance event system and as DOM events\nexport function emit(instance, event, data = {}) {\n  const { events, container } = instance;\n\n  // Call registered callbacks via instance.on()\n  if (events.has(event)) {\n    const callbacks = events.get(event);\n    callbacks.forEach((callback) => {\n      callback.call(instance, {\n        type: event,\n        target: instance,\n        ...data,\n      });\n    });\n  }\n\n  // Dispatch native DOM custom event for addEventListener compatibility\n  const customEvent = new CustomEvent(`carousel:${event}`, {\n    detail: { carousel: instance, ...data },\n    bubbles: true,\n  });\n  container.dispatchEvent(customEvent);\n}\n\n// Calculates and stores all dimensional measurements for the carousel\nexport function calculateDimensions(instance) {\n  const { track, items, state, config } = instance;\n\n  // Get computed styles to read CSS properties\n  const trackStyle = getComputedStyle(track);\n\n  const parseOffset = (value) => {\n    if (!value || value === 'auto') {\n      return { value: 0, specified: false };\n    }\n    const parsed = parseFloat(value);\n    if (Number.isNaN(parsed)) {\n      return { value: 0, specified: false };\n    }\n    return { value: parsed, specified: true };\n  };\n\n  // Read gap from CSS (try both gap and column-gap for compatibility)\n  const gap = parseFloat(trackStyle.gap || trackStyle.columnGap) || 0;\n\n  const paddingInlineStart = parseOffset(\n    trackStyle.paddingInlineStart || trackStyle.paddingLeft\n  );\n  const paddingInlineEnd = parseOffset(\n    trackStyle.paddingInlineEnd || trackStyle.paddingRight\n  );\n  const scrollPaddingInlineStart = parseOffset(\n    trackStyle.scrollPaddingInlineStart || trackStyle.scrollPaddingLeft\n  );\n  const scrollPaddingInlineEnd = parseOffset(\n    trackStyle.scrollPaddingInlineEnd || trackStyle.scrollPaddingRight\n  );\n\n  const startInset = scrollPaddingInlineStart.specified\n    ? scrollPaddingInlineStart.value\n    : paddingInlineStart.value;\n  const endInset = scrollPaddingInlineEnd.specified\n    ? scrollPaddingInlineEnd.value\n    : paddingInlineEnd.value;\n\n  // Measure container and scroll dimensions\n  const containerWidth = track.clientWidth;\n  const scrollWidth = track.scrollWidth;\n\n  // Calculate basic position data for active item detection\n  const trackRect = track.getBoundingClientRect();\n  const itemPositions = items.map((item, index) => {\n    const rect = item.getBoundingClientRect();\n    const itemStyle = getComputedStyle(item);\n\n    // Read scroll-margin for detection calculations\n    const marginStartValue = parseFloat(\n      itemStyle.scrollMarginInlineStart || itemStyle.scrollMarginLeft\n    );\n    const marginEndValue = parseFloat(\n      itemStyle.scrollMarginInlineEnd || itemStyle.scrollMarginRight\n    );\n    const marginStart = Number.isNaN(marginStartValue) ? 0 : marginStartValue;\n    const marginEnd = Number.isNaN(marginEndValue) ? 0 : marginEndValue;\n\n    // Calculate left position relative to track, accounting for current scroll\n    const left = rect.left - trackRect.left + track.scrollLeft;\n    const width = rect.width;\n\n    return {\n      index,\n      left,\n      width,\n      center: left + width / 2,\n      right: left + width,\n      marginStart,\n      marginEnd,\n    };\n  });\n\n  // Update state with measurements needed for detection\n  Object.assign(state, {\n    gap,\n    containerWidth,\n    scrollWidth,\n    itemPositions,\n    startInset,\n    endInset,\n  });\n\n  // Store snap alignment on instance for reference\n  instance.snapAlign = config.align;\n\n  console.log('[DEBUG calculateDimensions] Dimensions calculated:', {\n    gap,\n    containerWidth,\n    scrollWidth,\n    snapAlign: instance.snapAlign,\n    startInset,\n    endInset,\n    itemCount: itemPositions.length,\n  });\n}\n","// Navigation and pagination functionality\n\nimport { CONFIG } from './config.js';\nimport {\n  findActiveIndex,\n  debounce,\n  calculateTotalSlides,\n  emit,\n  calculateDimensions,\n} from './utils.js';\nimport { updateActiveClasses } from './keyboard.js';\n\n// Detects which item is currently active based on scroll position\nexport function detectActiveItem(instance) {\n  const { track, state, snapAlign } = instance;\n  const { itemPositions, currentIndex, startInset = 0, endInset = 0 } = state;\n\n  // Find the active index using scroll position\n  const scrollLeft = track.scrollLeft;\n  const activeIndex = findActiveIndex(\n    itemPositions,\n    scrollLeft,\n    state.containerWidth,\n    snapAlign,\n    {\n      startInset,\n      endInset,\n    }\n  );\n\n  console.log('[DEBUG detectActiveItem]', {\n    scrollLeft,\n    currentIndex,\n    activeIndex,\n    changed: activeIndex !== currentIndex,\n    startInset,\n    endInset,\n    itemPositions: itemPositions.map((p, i) => ({\n      index: i,\n      left: p.left,\n      width: p.width,\n    })),\n  });\n\n  // Only update if the active item has changed\n  if (activeIndex !== currentIndex) {\n    state.currentIndex = activeIndex;\n    updateUI(instance);\n    emit(instance, 'change', { index: activeIndex });\n  }\n}\n\n// Updates the disabled state of navigation buttons based on scroll position\nexport function updateButtonStates(instance) {\n  const { track, prevBtn, nextBtn, state } = instance;\n  const { CLASSES, TOLERANCE } = CONFIG;\n\n  const scrollLeft = track.scrollLeft;\n  const { scrollWidth, containerWidth } = state;\n  const maxScroll = scrollWidth - containerWidth;\n\n  // Detect edges with tolerance for fractional pixels\n  const atStart = scrollLeft <= TOLERANCE.EDGE_DETECTION;\n  const atEnd = scrollLeft >= maxScroll - TOLERANCE.EDGE_DETECTION;\n\n  console.log('[DEBUG updateButtonStates]', {\n    scrollLeft,\n    maxScroll,\n    atStart,\n    atEnd,\n    currentIndex: state.currentIndex,\n  });\n\n  // Update prev button state\n  if (prevBtn) {\n    prevBtn.classList.toggle(CLASSES.DISABLED, atStart);\n    prevBtn.disabled = atStart;\n\n    // Emit reach-start event only once when reaching start\n    if (atStart && !state.hasEmittedStart) {\n      emit(instance, 'reach-start');\n      state.hasEmittedStart = true;\n    } else if (!atStart) {\n      state.hasEmittedStart = false;\n    }\n  }\n\n  // Update next button state\n  if (nextBtn) {\n    nextBtn.classList.toggle(CLASSES.DISABLED, atEnd);\n    nextBtn.disabled = atEnd;\n\n    // Emit reach-end event only once when reaching end\n    if (atEnd && !state.hasEmittedEnd) {\n      emit(instance, 'reach-end');\n      state.hasEmittedEnd = true;\n    } else if (!atEnd) {\n      state.hasEmittedEnd = false;\n    }\n  }\n}\n\n// Handles scroll events on the track\nexport function handleScroll(instance) {\n  const { track } = instance;\n  const { CLASSES, TIMING } = CONFIG;\n\n  // Add scrolling class immediately for instant feedback\n  track.classList.add(CLASSES.SCROLLING);\n\n  // Emit scroll event with current position\n  emit(instance, 'scroll', { scrollLeft: track.scrollLeft });\n\n  // Create debounced handler on first scroll (lazy initialization)\n  if (!instance.debouncedScrollHandler) {\n    instance.debouncedScrollHandler = debounce(() => {\n      detectActiveItem(instance);\n      updateButtonStates(instance);\n      track.classList.remove(CLASSES.SCROLLING);\n    }, TIMING.DEBOUNCE_SCROLL);\n  }\n\n  // Execute debounced handler\n  instance.debouncedScrollHandler();\n}\n\n// Calculates the index of the next item for navigation\nexport function calculateNextIndex(instance) {\n  const { state, items } = instance;\n  const { currentIndex } = state;\n  const nextIndex = Math.min(currentIndex + 1, items.length - 1);\n  console.log('[DEBUG calculateNextIndex]', {\n    currentIndex,\n    nextIndex,\n    itemsLength: items.length,\n  });\n  return nextIndex;\n}\n\n// Calculates the index of the previous item for navigation\nexport function calculatePrevIndex(instance) {\n  const { state } = instance;\n  const { currentIndex } = state;\n  const prevIndex = Math.max(currentIndex - 1, 0);\n  console.log('[DEBUG calculatePrevIndex]', {\n    currentIndex,\n    prevIndex,\n  });\n  return prevIndex;\n}\n\n// Scrolls to a specific item index with smooth animation\nexport function scrollToItem(instance, index) {\n  const { track, items, state, snapAlign } = instance;\n  const { CLASSES, TIMING } = CONFIG;\n\n  console.log('[DEBUG scrollToItem] called with index:', index);\n\n  const targetItem = items[index];\n  if (!targetItem) {\n    console.warn(`Carousel ${instance.id}: No item found at index ${index}`);\n    return;\n  }\n\n  // Mark as animating to prevent concurrent navigation\n  state.isAnimating = true;\n  track.classList.add(CLASSES.ANIMATING);\n  track.classList.add(CLASSES.SNAP_DISABLED);\n\n  console.log('[DEBUG scrollToItem]', {\n    index,\n    snapAlign,\n    currentScrollLeft: track.scrollLeft,\n  });\n\n  // Browser handles positioning with respect to scroll-padding and scroll-margin\n  targetItem.scrollIntoView({\n    behavior: 'smooth',\n    block: 'nearest',\n    inline: snapAlign, // 'start', 'center', or 'end'\n  });\n\n  // Re-enable scroll-snap after short delay so native snap can take over\n  setTimeout(() => {\n    track.classList.remove(CLASSES.SNAP_DISABLED);\n  }, TIMING.SNAP_DISABLE_DURATION);\n\n  // Remove animating state after cooldown period\n  setTimeout(() => {\n    state.isAnimating = false;\n    track.classList.remove(CLASSES.ANIMATING);\n  }, TIMING.BUTTON_COOLDOWN);\n}\n\n// Handles next button click\nexport function handleNext(instance) {\n  const { state } = instance;\n  console.log('[DEBUG handleNext] called', {\n    isAnimating: state.isAnimating,\n    currentIndex: state.currentIndex,\n  });\n  if (state.isAnimating) return;\n\n  const targetIndex = calculateNextIndex(instance);\n  console.log('[DEBUG handleNext] scrolling to:', targetIndex);\n  scrollToItem(instance, targetIndex);\n}\n\n// Handles previous button click\nexport function handlePrev(instance) {\n  const { state, prevBtn } = instance;\n  console.log('[DEBUG handlePrev] called', {\n    isAnimating: state.isAnimating,\n    currentIndex: state.currentIndex,\n    buttonDisabled: prevBtn ? prevBtn.disabled : 'no button',\n  });\n  if (state.isAnimating) return;\n\n  const targetIndex = calculatePrevIndex(instance);\n  console.log('[DEBUG handlePrev] scrolling to:', targetIndex);\n  scrollToItem(instance, targetIndex);\n}\n\n// Sets up ResizeObserver to handle responsive behavior\nexport function setupResizeObserver(instance) {\n  const { container, track } = instance;\n  const { TIMING } = CONFIG;\n\n  // Create debounced resize handler\n  const debouncedResize = debounce(() => {\n    // Skip if container is hidden (offsetParent === null)\n    if (container.offsetParent === null) return;\n\n    // Recalculate everything and update UI\n    calculateDimensions(instance);\n    detectActiveItem(instance);\n    updateButtonStates(instance);\n  }, TIMING.DEBOUNCE_RESIZE);\n\n  // Store debounced handler for cleanup\n  instance.debouncedResizeHandler = debouncedResize;\n\n  // Create ResizeObserver instance\n  const resizeObserver = new ResizeObserver(() => {\n    debouncedResize();\n  });\n\n  // Observe container and track only (not items for performance)\n  resizeObserver.observe(container);\n  resizeObserver.observe(track);\n\n  // Store observer on instance for cleanup\n  instance.resizeObserver = resizeObserver;\n}\n\n// Sets up pagination dots if pagination container exists\nexport function setupPagination(instance) {\n  const { pagination, items, id } = instance;\n\n  // Skip if no pagination container exists\n  if (!pagination) return;\n\n  // Remove previously bound handlers before rebuilding dots\n  if (instance.boundDotHandlers) {\n    instance.boundDotHandlers.forEach(({ dot, handler }) => {\n      dot.removeEventListener('click', handler);\n    });\n  }\n\n  const totalSlides = calculateTotalSlides(items);\n  const existingDots = instance.dots ? [...instance.dots] : [];\n  if (existingDots.length === 0) {\n    console.warn(\n      `Carousel ${id}: At least one pagination dot is required inside the pagination container.`\n    );\n    return;\n  }\n  const syncedDots = [];\n\n  // Converts any provided dot into a semantic button so accessibility is consistent\n  const normalizeDotElement = (dot) => {\n    if (dot.tagName && dot.tagName.toLowerCase() === 'button') {\n      return dot;\n    }\n\n    const button = document.createElement('button');\n\n    [...dot.attributes].forEach((attribute) => {\n      button.setAttribute(attribute.name, attribute.value);\n    });\n\n    while (dot.firstChild) {\n      button.appendChild(dot.firstChild);\n    }\n\n    dot.replaceWith(button);\n    return button;\n  };\n\n  // Applies required attributes and binds events\n  const prepareDot = (dot, index) => {\n    const { CLASSES } = CONFIG;\n\n    dot.setAttribute('data-carousel', 'dot');\n    dot.setAttribute('type', 'button');\n\n    // Remove any pre-existing active class so scripted state controls visuals\n    dot.classList.remove(CLASSES.PAGINATION_ACTIVE);\n\n    const handler = () => instance.goTo(index);\n    dot.addEventListener('click', handler);\n    instance.boundDotHandlers.push({ dot, handler });\n    syncedDots.push(dot);\n  };\n\n  // Initialize handler storage\n  instance.boundDotHandlers = [];\n\n  const normalizedDots = existingDots.map((dot) => normalizeDotElement(dot));\n  const templateCount = normalizedDots.length;\n\n  while (normalizedDots.length < totalSlides) {\n    const templateDot = normalizedDots[normalizedDots.length % templateCount];\n    const duplicate = templateDot.cloneNode(true);\n    pagination.appendChild(duplicate);\n    normalizedDots.push(duplicate);\n  }\n\n  if (normalizedDots.length > totalSlides) {\n    const removedDots = normalizedDots.splice(totalSlides);\n    removedDots.forEach((dot) => {\n      dot.remove();\n    });\n  }\n\n  normalizedDots.forEach((dot, index) => {\n    prepareDot(dot, index);\n  });\n\n  // Update dots reference on instance\n  instance.dots = syncedDots;\n\n  // Set initial active state\n  updatePagination(instance);\n}\n\n// Updates pagination dots to reflect current active item\nexport function updatePagination(instance) {\n  const { dots, state } = instance;\n  const { CLASSES } = CONFIG;\n  const { currentIndex } = state;\n\n  // Skip if no dots exist\n  if (!dots || dots.length === 0) return;\n\n  // Update each dot's active state\n  dots.forEach((dot, index) => {\n    const isActive = index === currentIndex;\n    dot.classList.toggle(CLASSES.PAGINATION_ACTIVE, isActive);\n  });\n}\n\n// Batches DOM updates using requestAnimationFrame for better performance\nexport function updateUI(instance) {\n  const { rafPending } = instance;\n\n  // Avoid scheduling multiple RAF callbacks\n  if (rafPending) return;\n\n  instance.rafPending = true;\n  requestAnimationFrame(() => {\n    updateActiveClasses(instance);\n    updateButtonStates(instance);\n    updatePagination(instance);\n    instance.rafPending = false;\n  });\n}\n","// Keyboard navigation support\n\nimport { CONFIG } from './config.js';\n\n// Applies the active class to the current item and removes it from others\nexport function updateActiveClasses(instance) {\n  const { items, state } = instance;\n  const { CLASSES } = CONFIG;\n  const { currentIndex } = state;\n\n  items.forEach((item, index) => {\n    item.classList.toggle(CLASSES.ACTIVE, index === currentIndex);\n  });\n}\n\n// Sets up keyboard event listeners for navigation\nexport function setupKeyboardNavigation(instance, handlePrev, handleNext) {\n  const { container } = instance;\n\n  // Make container focusable if not already\n  if (!container.hasAttribute('tabindex')) {\n    container.setAttribute('tabindex', '0');\n  }\n\n  // Create and store bound handler\n  const handleKeydown = (event) => {\n    // Only handle keys if focus is on container or its children\n    if (!container.contains(event.target)) {\n      return;\n    }\n\n    // Handle navigation keys\n    switch (event.key) {\n      case 'ArrowLeft':\n        event.preventDefault();\n        handlePrev(instance);\n        break;\n\n      case 'ArrowRight':\n        event.preventDefault();\n        handleNext(instance);\n        break;\n\n      case 'Home':\n        event.preventDefault();\n        instance.goTo(0);\n        break;\n\n      case 'End':\n        event.preventDefault();\n        instance.goTo(instance.items.length - 1);\n        break;\n    }\n  };\n\n  // Store handler for cleanup\n  instance.boundHandlers.keyboard = handleKeydown;\n\n  // Attach listener to container\n  container.addEventListener('keydown', handleKeydown);\n}\n","// Main Carousel class and core functionality\n\nimport { CONFIG } from './config.js';\nimport {\n  generateUniqueId,\n  parseConfig,\n  emit,\n  calculateDimensions,\n} from './utils.js';\nimport {\n  detectActiveItem,\n  handleScroll,\n  scrollToItem,\n  handleNext,\n  handlePrev,\n  setupResizeObserver,\n  setupPagination,\n  updateUI,\n} from './navigation.js';\nimport { setupKeyboardNavigation } from './keyboard.js';\n\n// Finds and validates all required and optional elements within the carousel container\nfunction findElements(instance) {\n  const { container, id } = instance;\n  const { SELECTORS } = CONFIG;\n\n  // Find required track element\n  const track = container.querySelector(SELECTORS.TRACK);\n  if (!track) {\n    console.warn(\n      `Carousel ${id}: Track element not found. Expected element with data-carousel=\"track\".`\n    );\n    return false;\n  }\n\n  // Find required item elements\n  const items = [...container.querySelectorAll(SELECTORS.ITEM)];\n  console.log('[DEBUG findElements] Items found:', {\n    count: items.length,\n    items: items.map((item, i) => ({\n      index: i,\n      textContent: item.textContent?.substring(0, 30),\n      classList: Array.from(item.classList),\n    })),\n  });\n  if (items.length === 0) {\n    console.warn(\n      `Carousel ${id}: No items found. Expected at least one element with data-carousel=\"item\".`\n    );\n    return false;\n  }\n\n  // Find optional navigation buttons (no warning if missing)\n  const prevBtn = container.querySelector(SELECTORS.PREV_BTN);\n  const nextBtn = container.querySelector(SELECTORS.NEXT_BTN);\n\n  // Find optional pagination container and dots\n  const pagination = container.querySelector(SELECTORS.PAGINATION);\n  let dots = [];\n  if (pagination) {\n    dots = [...pagination.querySelectorAll(SELECTORS.DOT)];\n  }\n\n  // Add data-carousel-id for easier debugging in devtools\n  container.setAttribute('data-carousel-id', id);\n\n  // Store all element references on the instance\n  Object.assign(instance, {\n    track,\n    items,\n    prevBtn,\n    nextBtn,\n    pagination,\n    dots,\n  });\n\n  return true;\n}\n\n// Attaches event listeners for user interactions\nfunction attachEventListeners(instance) {\n  const { track, prevBtn, nextBtn, id } = instance;\n\n  // Create bound handlers and store them for later removal\n  instance.boundHandlers = {\n    scroll: () => handleScroll(instance),\n    prev: () => handlePrev(instance),\n    next: () => handleNext(instance),\n  };\n\n  // Attach scroll listener with passive flag for better performance\n  track.addEventListener('scroll', instance.boundHandlers.scroll, {\n    passive: true,\n  });\n\n  // Attach button listeners if buttons exist\n  if (prevBtn) {\n    prevBtn.addEventListener('click', instance.boundHandlers.prev);\n  }\n  if (nextBtn) {\n    nextBtn.addEventListener('click', instance.boundHandlers.next);\n  }\n}\n\n// Cleans up all event listeners, observers, and references\nfunction cleanup(instance) {\n  const { prevBtn, nextBtn, track, container } = instance;\n\n  // Remove event listeners using stored bound handlers\n  if (instance.boundHandlers) {\n    track.removeEventListener('scroll', instance.boundHandlers.scroll);\n\n    if (prevBtn) {\n      prevBtn.removeEventListener('click', instance.boundHandlers.prev);\n    }\n    if (nextBtn) {\n      nextBtn.removeEventListener('click', instance.boundHandlers.next);\n    }\n\n    // Remove keyboard listener if it exists\n    if (instance.boundHandlers.keyboard) {\n      container.removeEventListener('keydown', instance.boundHandlers.keyboard);\n    }\n  }\n\n  // Remove pagination dot event listeners\n  if (instance.boundDotHandlers) {\n    instance.boundDotHandlers.forEach(({ dot, handler }) => {\n      dot.removeEventListener('click', handler);\n    });\n  }\n\n  // Disconnect ResizeObserver\n  if (instance.resizeObserver) {\n    instance.resizeObserver.disconnect();\n    instance.resizeObserver = null;\n  }\n\n  // Clear all instance properties to help garbage collection\n  Object.keys(instance).forEach((key) => {\n    instance[key] = null;\n  });\n}\n\n// Initializes the carousel instance\nfunction init(instance) {\n  // Find and validate elements first\n  const elementsFound = findElements(instance);\n  if (!elementsFound) {\n    return false;\n  }\n\n  // Calculate initial dimensions\n  calculateDimensions(instance);\n\n  // Attach event listeners\n  attachEventListeners(instance);\n\n  // Set up responsive behavior\n  setupResizeObserver(instance);\n\n  // Set up pagination if container exists\n  setupPagination(instance);\n\n  // Set up keyboard navigation if enabled\n  if (instance.config.keyboard) {\n    setupKeyboardNavigation(instance, handlePrev, handleNext);\n  }\n\n  // Set initial UI state\n  updateUI(instance);\n\n  console.log('[DEBUG init] Carousel initialized', {\n    id: instance.id,\n    currentIndex: instance.state.currentIndex,\n    itemCount: instance.items.length,\n    scrollLeft: instance.track.scrollLeft,\n  });\n\n  return true;\n}\n\n// Main Carousel class\nexport class Carousel {\n  constructor(container) {\n    const id = generateUniqueId();\n    const config = parseConfig(container);\n\n    // Initialize state object with all tracking properties\n    const state = {\n      currentIndex: 0,\n      isScrolling: false,\n      isAnimating: false,\n      itemPositions: [],\n      gap: 0,\n      containerWidth: 0,\n      scrollWidth: 0,\n      startInset: 0,\n      endInset: 0,\n      hasEmittedStart: false,\n      hasEmittedEnd: false,\n    };\n\n    // Store core properties on instance\n    Object.assign(this, {\n      container,\n      id,\n      config,\n      state,\n      events: new Map(),\n      rafPending: false,\n      boundHandlers: null,\n      debouncedScrollHandler: null,\n    });\n\n    // Initialize the carousel\n    const initialized = init(this);\n    if (!initialized) {\n      console.warn(\n        `Carousel ${id}: Initialization failed due to missing required elements.`\n      );\n    }\n  }\n\n  // Navigates to the next item\n  next() {\n    handleNext(this);\n    return this;\n  }\n\n  // Navigates to the previous item\n  prev() {\n    handlePrev(this);\n    return this;\n  }\n\n  // Navigates to a specific item by index\n  goTo(index) {\n    const { items } = this;\n    if (index < 0 || index >= items.length) {\n      console.warn(\n        `Carousel ${this.id}: Invalid index ${index}. Must be between 0 and ${\n          items.length - 1\n        }.`\n      );\n      return this;\n    }\n    scrollToItem(this, index);\n    return this;\n  }\n\n  // Returns the current active item index\n  getActiveIndex() {\n    return this.state.currentIndex;\n  }\n\n  // Manually recalculates dimensions and updates UI\n  refresh() {\n    calculateDimensions(this);\n    detectActiveItem(this);\n    updateUI(this);\n    return this;\n  }\n\n  // Destroys the carousel instance and cleans up all resources\n  destroy() {\n    cleanup(this);\n    return null;\n  }\n\n  // Subscribes to a carousel event\n  on(event, callback) {\n    const { events } = this;\n    if (!events.has(event)) {\n      events.set(event, []);\n    }\n    events.get(event).push(callback);\n    return this;\n  }\n\n  // Unsubscribes from a carousel event\n  off(event, callback) {\n    const { events } = this;\n    if (!events.has(event)) return this;\n\n    const callbacks = events.get(event);\n    const index = callbacks.indexOf(callback);\n    if (index > -1) {\n      callbacks.splice(index, 1);\n    }\n    return this;\n  }\n\n  // Static method for manual initialization\n  static init(container) {\n    if (typeof container === 'string') {\n      container = document.querySelector(container);\n    }\n    if (!container) {\n      throw new Error('Carousel.init(): Container element not found');\n    }\n    return new Carousel(container);\n  }\n}\n","// Entry point for the carousel library\n\nimport { Carousel } from './core.js';\nimport { SELECTORS } from './config.js';\n\n// Global registry to store all initialized carousel instances\nconst instances = new Map();\n\n// Auto-initializes all carousels on the page when DOM is ready\nfunction autoInit() {\n  const containers = document.querySelectorAll(SELECTORS.CONTAINER);\n\n  containers.forEach((container) => {\n    try {\n      const carousel = new Carousel(container);\n      if (carousel.id) {\n        instances.set(carousel.id, carousel);\n      }\n    } catch (error) {\n      console.warn('Carousel auto-initialization failed:', error);\n    }\n  });\n\n  if (instances.size > 0) {\n    console.log(`Carousel: Initialized ${instances.size} instance(s)`);\n  }\n}\n\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\nif (typeof window !== 'undefined') {\n  window.Carousel = Carousel;\n  window.CarouselInstances = instances;\n}\n"],"names":["SELECTORS","CONTAINER","TRACK","ITEM","PREV_BTN","NEXT_BTN","PAGINATION","DOT","DEFAULTS","CONFIG","CLASSES","SCROLLING","DISABLED","ACTIVE","ANIMATING","SNAP_DISABLED","PAGINATION_ACTIVE","TIMING","DEBOUNCE_RESIZE","DEBOUNCE_SCROLL","BUTTON_COOLDOWN","SNAP_DISABLE_DURATION","TOLERANCE","EDGE_DETECTION","idCounter","debounce","func","wait","timeout","args","clearTimeout","setTimeout","emit","instance","event","data","events","container","has","get","forEach","callback","call","type","target","customEvent","CustomEvent","detail","carousel","bubbles","dispatchEvent","calculateDimensions","track","items","state","config","trackStyle","getComputedStyle","parseOffset","value","specified","parsed","parseFloat","Number","isNaN","gap","columnGap","paddingInlineStart","paddingLeft","paddingInlineEnd","paddingRight","scrollPaddingInlineStart","scrollPaddingLeft","scrollPaddingInlineEnd","scrollPaddingRight","startInset","endInset","containerWidth","clientWidth","scrollWidth","trackRect","getBoundingClientRect","itemPositions","map","item","index","rect","itemStyle","marginStartValue","scrollMarginInlineStart","scrollMarginLeft","marginEndValue","scrollMarginInlineEnd","scrollMarginRight","marginStart","marginEnd","left","scrollLeft","width","center","right","Object","assign","snapAlign","align","console","log","itemCount","length","detectActiveItem","currentIndex","activeIndex","options","referencePoint","offsets","calculateReferencePoint","closestIndex","minDistance","Infinity","distances","itemPoint","getItemAlignmentPoint","distance","Math","abs","push","findActiveIndex","changed","p","i","updateUI","updateButtonStates","prevBtn","nextBtn","maxScroll","atStart","atEnd","classList","toggle","disabled","hasEmittedStart","hasEmittedEnd","scrollToItem","targetItem","isAnimating","add","currentScrollLeft","scrollIntoView","behavior","block","inline","remove","warn","id","handleNext","targetIndex","nextIndex","min","itemsLength","calculateNextIndex","handlePrev","buttonDisabled","prevIndex","max","calculatePrevIndex","setupPagination","pagination","boundDotHandlers","dot","handler","removeEventListener","totalSlides","Array","isArray","calculateTotalSlides","existingDots","dots","syncedDots","normalizedDots","tagName","toLowerCase","button","document","createElement","attributes","attribute","setAttribute","name","firstChild","appendChild","replaceWith","normalizeDotElement","templateCount","duplicate","cloneNode","splice","goTo","addEventListener","prepareDot","updatePagination","isActive","rafPending","requestAnimationFrame","updateActiveClasses","attachEventListeners","boundHandlers","scroll","debouncedScrollHandler","handleScroll","prev","next","passive","init","elementsFound","querySelector","querySelectorAll","count","textContent","substring","from","findElements","debouncedResize","offsetParent","debouncedResizeHandler","resizeObserver","ResizeObserver","observe","setupResizeObserver","keyboard","hasAttribute","handleKeydown","contains","key","preventDefault","setupKeyboardNavigation","Carousel","constructor","getAttribute","scrollBy","loop","parseConfig","this","isScrolling","Map","getActiveIndex","refresh","destroy","disconnect","keys","cleanup","on","set","off","callbacks","indexOf","Error","instances","autoInit","error","size","readyState","window","CarouselInstances"],"mappings":"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"}