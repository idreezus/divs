{"version":3,"file":"scroll-fade.min.js","sources":["../../../packages/scroll-fade/src/config.js","../../../packages/scroll-fade/src/utils.js","../../../packages/scroll-fade/src/core.js","../../../packages/scroll-fade/src/scroll-fade.js"],"sourcesContent":["// Configuration constants for the scroll-fade library\n\n// Builds a presence-based selector with opt-out support\nconst sel = (attr) => `[${attr}]:not([${attr}=\"false\"])`;\n\n// Raw attribute names for marker (presence-based) elements\nexport const selectorAttrs = {\n  container: 'data-scroll-fade-container',\n  list: 'data-scroll-fade-list',\n  prev: 'data-scroll-fade-prev',\n  next: 'data-scroll-fade-next',\n};\n\n// DOM query selectors (marker attrs auto-derived, value attrs manual)\nexport const selectors = {\n  ...Object.fromEntries(\n    Object.entries(selectorAttrs).map(([k, v]) => [k, sel(v)])\n  ),\n  start: '[data-scroll-fade=\"start\"]',\n  end: '[data-scroll-fade=\"end\"]',\n};\n\n// Attribute names for configuration\nexport const attributes = {\n  // Container markers\n  container: 'data-scroll-fade-container',\n  list: 'data-scroll-fade-list',\n  prev: 'data-scroll-fade-prev',\n  next: 'data-scroll-fade-next',\n\n  // Container configuration\n  orientation: 'data-scroll-fade-orientation',\n  step: 'data-scroll-fade-step',\n  id: 'data-scroll-fade-id',\n};\n\n// CSS classes applied to elements\nexport const classes = {\n  // Shadow visibility\n  hidden: 'scroll-fade-hidden',\n\n  // Button state\n  buttonDisabled: 'scroll-fade-button-disabled',\n};\n\n// Event names for CustomEvents (prefixed with 'scroll-fade:' when dispatched)\nexport const events = {\n  reachStart: 'reach-start',\n  reachEnd: 'reach-end',\n  show: 'show',\n  hide: 'hide',\n};\n\n// Default configuration values\nexport const defaults = {\n  orientation: 'horizontal',\n  step: null, // Defaults to container clientWidth/clientHeight\n};\n\n// Internal constants\nexport const EDGE_THRESHOLD = 1; // pixels\n","// Shared utility functions for the scroll-fade library\n\nimport { EDGE_THRESHOLD, attributes, defaults } from './config.js';\n\nlet idCounter = 0;\n\n// Generates a unique ID for each scroll-fade instance\nexport function generateUniqueId() {\n  idCounter += 1;\n  return `scroll-fade-${idCounter}`;\n}\n\n// Checks if a presence-based attribute is enabled (exists AND !== \"false\")\nexport function isAttributeEnabled(element, attrName) {\n  if (!element.hasAttribute(attrName)) return false;\n  return element.getAttribute(attrName) !== 'false';\n}\n\n// Parses configuration from element data attributes\nexport function parseConfig(element) {\n  const orientation =\n    element.getAttribute(attributes.orientation) || defaults.orientation;\n\n  const stepAttr = element.getAttribute(attributes.step);\n  const step = stepAttr ? parseInt(stepAttr, 10) : defaults.step;\n\n  return {\n    orientation,\n    step,\n  };\n}\n\n// Emits DOM CustomEvent on the container element\nexport function emit(instance, eventName, data = {}) {\n  const { container } = instance;\n\n  const customEvent = new CustomEvent(`scroll-fade:${eventName}`, {\n    detail: { scrollFade: instance, ...data },\n    bubbles: true,\n  });\n  container.dispatchEvent(customEvent);\n}\n\n// Gets text direction using Intl.Locale API for RTL detection\nexport function getTextDirection() {\n  try {\n    const locale = new Intl.Locale(navigator.language);\n    if (locale.getTextInfo) {\n      return locale.getTextInfo().direction;\n    }\n  } catch {\n    // Fallback if Intl.Locale.getTextInfo is not supported\n  }\n\n  // Fallback: check document direction\n  const dir = document.documentElement.getAttribute('dir');\n  if (dir) return dir;\n\n  // Final fallback: check computed style\n  return getComputedStyle(document.documentElement).direction || 'ltr';\n}\n\n// Checks if the container has scrollable content\nexport function isScrollable(container, orientation) {\n  if (orientation === 'horizontal') {\n    return container.scrollWidth > container.clientWidth;\n  }\n  return container.scrollHeight > container.clientHeight;\n}\n\n// Gets the current scroll position\nexport function getScrollPosition(container, orientation) {\n  if (orientation === 'horizontal') {\n    return container.scrollLeft;\n  }\n  return container.scrollTop;\n}\n\n// Calculates the maximum scroll value\nexport function getMaxScroll(container, orientation) {\n  if (orientation === 'horizontal') {\n    return container.scrollWidth - container.clientWidth;\n  }\n  return container.scrollHeight - container.clientHeight;\n}\n\n// Checks if scroll is at the start (within threshold)\nexport function isAtStart(container, orientation) {\n  const position = getScrollPosition(container, orientation);\n  return position <= EDGE_THRESHOLD;\n}\n\n// Checks if scroll is at the end (within threshold)\nexport function isAtEnd(container, orientation) {\n  const position = getScrollPosition(container, orientation);\n  const maxScroll = getMaxScroll(container, orientation);\n  return position >= maxScroll - EDGE_THRESHOLD;\n}\n\n// Gets the scroll step value (configured or default to container size)\nexport function getScrollStep(container, config) {\n  if (config.step !== null) {\n    return config.step;\n  }\n\n  // Default to container client size\n  if (config.orientation === 'horizontal') {\n    return container.clientWidth;\n  }\n  return container.clientHeight;\n}\n","// Core ScrollFade class implementation\n\nimport { selectors, attributes, classes, events } from './config.js';\nimport {\n  generateUniqueId,\n  parseConfig,\n  emit,\n  getTextDirection,\n  isScrollable,\n  isAtStart,\n  isAtEnd,\n  getMaxScroll,\n  getScrollStep,\n} from './utils.js';\n\nexport class ScrollFade {\n  constructor(container) {\n    this.id = generateUniqueId();\n    this.container = container;\n    this.list = null;\n    this.config = null;\n\n    this.state = {\n      isAtStart: true,\n      isAtEnd: false,\n      isVisible: true,\n      isScrollable: false,\n    };\n\n    // Element references\n    this.startShadow = null;\n    this.endShadow = null;\n    this.prevBtn = null;\n    this.nextBtn = null;\n\n    // Bound handlers for cleanup\n    this.boundHandlers = null;\n\n    // Observers\n    this.resizeObserver = null;\n    this.intersectionObserver = null;\n\n    // RAF tracking\n    this.rafId = null;\n\n    // Initialize\n    const initialized = this.init();\n    if (initialized) {\n      this.container._scrollFade = this;\n      this.container.setAttribute(attributes.id, this.id);\n    }\n  }\n\n  init() {\n    // Find required elements within container\n    if (!this.findElements()) {\n      return false;\n    }\n\n    // Parse config from list element\n    this.config = parseConfig(this.list);\n\n    // Validate list has overflow CSS\n    this.validateOverflow();\n\n    // Check initial scrollability\n    this.state.isScrollable = isScrollable(this.list, this.config.orientation);\n\n    // Setup observers\n    this.setupObservers();\n\n    // Bind event handlers\n    this.bindHandlers();\n\n    // Wire navigation buttons if present\n    this.wireNavigationButtons();\n\n    // Update initial state and fire events\n    this.updateState(true);\n\n    return true;\n  }\n\n  validateOverflow() {\n    const style = getComputedStyle(this.list);\n    const prop =\n      this.config.orientation === 'horizontal' ? 'overflowX' : 'overflowY';\n    const overflow = style[prop];\n\n    if (overflow !== 'auto' && overflow !== 'scroll') {\n      console.warn(\n        `ScrollFade: List element should have overflow-${this.config.orientation === 'horizontal' ? 'x' : 'y'}: auto or scroll.`,\n        this.list\n      );\n    }\n  }\n\n  findElements() {\n    // Find scrollable list element\n    this.list = this.container.querySelector(selectors.list);\n    if (!this.list) {\n      console.error(\n        `ScrollFade: No list element found. Expected [data-scroll-fade-list] inside container.`,\n        this.container\n      );\n      return false;\n    }\n\n    // Find shadow elements (user provides these in markup)\n    this.startShadow = this.container.querySelector(selectors.start);\n    this.endShadow = this.container.querySelector(selectors.end);\n\n    if (!this.startShadow || !this.endShadow) {\n      console.warn(\n        `ScrollFade: Shadow elements not found. Expected [data-scroll-fade=\"start\"] and [data-scroll-fade=\"end\"].`,\n        this.container\n      );\n    }\n\n    return true;\n  }\n\n  setupObservers() {\n    // ResizeObserver for dynamic scrollability changes\n    this.resizeObserver = new ResizeObserver(() => {\n      this.recalculate();\n    });\n    this.resizeObserver.observe(this.list);\n\n    // IntersectionObserver to pause when not visible\n    this.intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        const entry = entries[0];\n        this.state.isVisible = entry.isIntersecting;\n      },\n      { threshold: 0 }\n    );\n    this.intersectionObserver.observe(this.list);\n  }\n\n  bindHandlers() {\n    this.boundHandlers = {\n      scroll: () => this.handleScroll(),\n    };\n\n    this.list.addEventListener('scroll', this.boundHandlers.scroll, {\n      passive: true,\n    });\n  }\n\n  wireNavigationButtons() {\n    // Find buttons scoped to this container\n    this.prevBtn = this.container.querySelector(selectors.prev);\n    this.nextBtn = this.container.querySelector(selectors.next);\n\n    if (this.prevBtn) {\n      this.boundHandlers.prev = () => this.scrollPrev();\n      this.prevBtn.addEventListener('click', this.boundHandlers.prev);\n    }\n\n    if (this.nextBtn) {\n      this.boundHandlers.next = () => this.scrollNext();\n      this.nextBtn.addEventListener('click', this.boundHandlers.next);\n    }\n  }\n\n  handleScroll() {\n    // Skip if not visible (IntersectionObserver optimization)\n    if (!this.state.isVisible) return;\n\n    // Use RAF for smooth updates\n    if (this.rafId) {\n      cancelAnimationFrame(this.rafId);\n    }\n\n    this.rafId = requestAnimationFrame(() => {\n      this.updateState(false);\n    });\n  }\n\n  updateState(isInitial) {\n    const wasAtStart = this.state.isAtStart;\n    const wasAtEnd = this.state.isAtEnd;\n    const wasScrollable = this.state.isScrollable;\n\n    // Recalculate state using list element\n    this.state.isScrollable = isScrollable(this.list, this.config.orientation);\n    this.state.isAtStart = isAtStart(this.list, this.config.orientation);\n    this.state.isAtEnd = isAtEnd(this.list, this.config.orientation);\n\n    // If not scrollable, both shadows should be hidden\n    if (!this.state.isScrollable) {\n      this.updateShadowVisibility('start', false, isInitial);\n      this.updateShadowVisibility('end', false, isInitial);\n      this.updateButtonStates();\n      return;\n    }\n\n    // Update start shadow visibility\n    const startVisible = !this.state.isAtStart;\n    const startWasVisible = wasScrollable && !wasAtStart;\n\n    if (isInitial || startVisible !== startWasVisible) {\n      this.updateShadowVisibility('start', startVisible, isInitial);\n    }\n\n    // Update end shadow visibility\n    const endVisible = !this.state.isAtEnd;\n    const endWasVisible = wasScrollable && !wasAtEnd;\n\n    if (isInitial || endVisible !== endWasVisible) {\n      this.updateShadowVisibility('end', endVisible, isInitial);\n    }\n\n    // Emit reach events\n    if (!isInitial) {\n      if (this.state.isAtStart && !wasAtStart) {\n        emit(this, events.reachStart);\n      }\n      if (this.state.isAtEnd && !wasAtEnd) {\n        emit(this, events.reachEnd);\n      }\n    } else {\n      // Fire initial reach events if at edge\n      if (this.state.isAtStart) {\n        emit(this, events.reachStart);\n      }\n      if (this.state.isAtEnd) {\n        emit(this, events.reachEnd);\n      }\n    }\n\n    // Update button states\n    this.updateButtonStates();\n  }\n\n  updateShadowVisibility(edge, visible, isInitial) {\n    const shadow = edge === 'start' ? this.startShadow : this.endShadow;\n\n    if (visible) {\n      shadow.classList.remove(classes.hidden);\n    } else {\n      shadow.classList.add(classes.hidden);\n    }\n\n    // Emit show/hide event\n    const eventName = visible ? events.show : events.hide;\n    emit(this, eventName, { edge });\n  }\n\n  updateButtonStates() {\n    if (this.prevBtn) {\n      if (this.state.isAtStart || !this.state.isScrollable) {\n        this.prevBtn.classList.add(classes.buttonDisabled);\n        this.prevBtn.setAttribute('aria-disabled', 'true');\n      } else {\n        this.prevBtn.classList.remove(classes.buttonDisabled);\n        this.prevBtn.removeAttribute('aria-disabled');\n      }\n    }\n\n    if (this.nextBtn) {\n      if (this.state.isAtEnd || !this.state.isScrollable) {\n        this.nextBtn.classList.add(classes.buttonDisabled);\n        this.nextBtn.setAttribute('aria-disabled', 'true');\n      } else {\n        this.nextBtn.classList.remove(classes.buttonDisabled);\n        this.nextBtn.removeAttribute('aria-disabled');\n      }\n    }\n  }\n\n  scrollPrev() {\n    const step = getScrollStep(this.list, this.config);\n    const isRtl = getTextDirection() === 'rtl';\n    const isHorizontal = this.config.orientation === 'horizontal';\n\n    if (isHorizontal) {\n      // In RTL, \"prev\" scrolls right (positive)\n      const scrollAmount = isRtl ? step : -step;\n      this.list.scrollBy({\n        left: scrollAmount,\n        behavior: 'smooth',\n      });\n    } else {\n      this.list.scrollBy({\n        top: -step,\n        behavior: 'smooth',\n      });\n    }\n  }\n\n  scrollNext() {\n    const step = getScrollStep(this.list, this.config);\n    const isRtl = getTextDirection() === 'rtl';\n    const isHorizontal = this.config.orientation === 'horizontal';\n\n    if (isHorizontal) {\n      // In RTL, \"next\" scrolls left (negative)\n      const scrollAmount = isRtl ? -step : step;\n      this.list.scrollBy({\n        left: scrollAmount,\n        behavior: 'smooth',\n      });\n    } else {\n      this.list.scrollBy({\n        top: step,\n        behavior: 'smooth',\n      });\n    }\n  }\n\n  recalculate() {\n    this.updateState(false);\n  }\n\n  // Public API\n\n  scrollToStart() {\n    const isHorizontal = this.config.orientation === 'horizontal';\n    const isRtl = getTextDirection() === 'rtl';\n\n    if (isHorizontal) {\n      const scrollTarget = isRtl\n        ? getMaxScroll(this.list, this.config.orientation)\n        : 0;\n      this.list.scrollTo({\n        left: scrollTarget,\n        behavior: 'smooth',\n      });\n    } else {\n      this.list.scrollTo({\n        top: 0,\n        behavior: 'smooth',\n      });\n    }\n\n    return this;\n  }\n\n  scrollToEnd() {\n    const isHorizontal = this.config.orientation === 'horizontal';\n    const isRtl = getTextDirection() === 'rtl';\n    const maxScroll = getMaxScroll(this.list, this.config.orientation);\n\n    if (isHorizontal) {\n      const scrollTarget = isRtl ? 0 : maxScroll;\n      this.list.scrollTo({\n        left: scrollTarget,\n        behavior: 'smooth',\n      });\n    } else {\n      this.list.scrollTo({\n        top: maxScroll,\n        behavior: 'smooth',\n      });\n    }\n\n    return this;\n  }\n\n  refresh() {\n    // Disconnect observers\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n    }\n\n    // Reconnect observers\n    this.setupObservers();\n\n    // Recalculate state\n    this.updateState(false);\n\n    return this;\n  }\n\n  destroy() {\n    // Cancel any pending RAF\n    if (this.rafId) {\n      cancelAnimationFrame(this.rafId);\n    }\n\n    // Disconnect observers\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n    }\n\n    // Remove scroll listener from list\n    if (this.boundHandlers && this.list) {\n      this.list.removeEventListener('scroll', this.boundHandlers.scroll);\n    }\n\n    // Remove navigation button listeners\n    if (this.prevBtn && this.boundHandlers?.prev) {\n      this.prevBtn.removeEventListener('click', this.boundHandlers.prev);\n    }\n    if (this.nextBtn && this.boundHandlers?.next) {\n      this.nextBtn.removeEventListener('click', this.boundHandlers.next);\n    }\n    this.prevBtn = null;\n    this.nextBtn = null;\n\n    // Clean up shadow classes (don't remove elements - user owns them)\n    if (this.startShadow) {\n      this.startShadow.classList.remove(classes.hidden);\n    }\n    if (this.endShadow) {\n      this.endShadow.classList.remove(classes.hidden);\n    }\n\n    // Remove instance reference from container\n    delete this.container._scrollFade;\n\n    // Remove instance ID attribute\n    this.container.removeAttribute(attributes.id);\n  }\n}\n","// ScrollFade entry point with auto-initialization\n\nimport { selectors } from './config.js';\nimport { ScrollFade } from './core.js';\n\n// Auto-initialize all scroll-fade containers\nfunction autoInit() {\n  const containers = document.querySelectorAll(selectors.container);\n\n  containers.forEach((container) => {\n    // Skip already initialized containers\n    if (container._scrollFade) return;\n\n    try {\n      new ScrollFade(container);\n    } catch (error) {\n      console.warn('ScrollFade auto-initialization failed:', error);\n    }\n  });\n}\n\n// Run auto-init when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\n// Export for manual usage\nexport { ScrollFade };\n"],"names":["selectors","Object","fromEntries","entries","container","list","prev","next","map","k","v","attr","start","end","attributes","classes","events","defaults","idCounter","emit","instance","eventName","data","customEvent","CustomEvent","detail","scrollFade","bubbles","dispatchEvent","getTextDirection","locale","Intl","Locale","navigator","language","getTextInfo","direction","dir","document","documentElement","getAttribute","getComputedStyle","isScrollable","orientation","scrollWidth","clientWidth","scrollHeight","clientHeight","getScrollPosition","scrollLeft","scrollTop","getMaxScroll","getScrollStep","config","step","ScrollFade","constructor","this","id","state","isAtStart","isAtEnd","isVisible","startShadow","endShadow","prevBtn","nextBtn","boundHandlers","resizeObserver","intersectionObserver","rafId","init","_scrollFade","setAttribute","findElements","element","stepAttr","parseInt","parseConfig","validateOverflow","setupObservers","bindHandlers","wireNavigationButtons","updateState","overflow","console","warn","querySelector","error","ResizeObserver","recalculate","observe","IntersectionObserver","entry","isIntersecting","threshold","scroll","handleScroll","addEventListener","passive","scrollPrev","scrollNext","cancelAnimationFrame","requestAnimationFrame","isInitial","wasAtStart","wasAtEnd","wasScrollable","updateShadowVisibility","updateButtonStates","startVisible","endVisible","edge","visible","shadow","classList","remove","add","removeAttribute","isRtl","scrollAmount","scrollBy","left","behavior","top","scrollToStart","isHorizontal","scrollTarget","scrollTo","scrollToEnd","maxScroll","refresh","disconnect","destroy","removeEventListener","autoInit","querySelectorAll","forEach","readyState"],"mappings":"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"}