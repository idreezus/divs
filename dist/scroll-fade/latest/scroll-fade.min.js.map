{"version":3,"file":"scroll-fade.min.js","sources":["../../../packages/scroll-fade/src/config.js","../../../packages/scroll-fade/src/utils.js","../../../packages/scroll-fade/src/core.js","../../../packages/scroll-fade/src/scroll-fade.js"],"sourcesContent":["// Configuration constants for the scroll-fade library\n\n// Selectors for querying DOM elements\n// Presence-based: attribute exists and value !== \"false\"\nexport const selectors = {\n  container:\n    '[data-scroll-fade-container]:not([data-scroll-fade-container=\"false\"])',\n  prev: '[data-scroll-fade-prev]:not([data-scroll-fade-prev=\"false\"])',\n  next: '[data-scroll-fade-next]:not([data-scroll-fade-next=\"false\"])',\n};\n\n// Attribute names for configuration\nexport const attributes = {\n  // Container markers\n  container: 'data-scroll-fade-container',\n  prev: 'data-scroll-fade-prev',\n  next: 'data-scroll-fade-next',\n\n  // Container configuration\n  orientation: 'data-scroll-fade-orientation',\n  step: 'data-scroll-fade-step',\n  id: 'data-scroll-fade-id',\n};\n\n// CSS classes applied to elements\nexport const classes = {\n  // Shadow visibility\n  hidden: 'scroll-fade-hidden',\n\n  // Button state\n  buttonDisabled: 'scroll-fade-button-disabled',\n};\n\n// Event names for CustomEvents (prefixed with 'scroll-fade:' when dispatched)\nexport const events = {\n  reachStart: 'reach-start',\n  reachEnd: 'reach-end',\n  show: 'show',\n  hide: 'hide',\n};\n\n// Default configuration values\nexport const defaults = {\n  orientation: 'horizontal',\n  step: null, // Defaults to container clientWidth/clientHeight\n};\n\n// Internal constants\nexport const EDGE_THRESHOLD = 1; // pixels\n","// Shared utility functions for the scroll-fade library\n\nimport { EDGE_THRESHOLD, attributes, defaults } from './config.js';\n\nlet idCounter = 0;\n\n// Generates a unique ID for each scroll-fade instance\nexport function generateUniqueId() {\n  idCounter += 1;\n  return `scroll-fade-${idCounter}`;\n}\n\n// Checks if a presence-based attribute is enabled (exists AND !== \"false\")\nexport function isAttributeEnabled(element, attrName) {\n  if (!element.hasAttribute(attrName)) return false;\n  return element.getAttribute(attrName) !== 'false';\n}\n\n// Parses configuration from container data attributes\nexport function parseConfig(container) {\n  const orientation =\n    container.getAttribute(attributes.orientation) || defaults.orientation;\n\n  const stepAttr = container.getAttribute(attributes.step);\n  const step = stepAttr ? parseInt(stepAttr, 10) : defaults.step;\n\n  return {\n    orientation,\n    step,\n  };\n}\n\n// Emits DOM CustomEvent on the container element\nexport function emit(instance, eventName, data = {}) {\n  const { container } = instance;\n\n  const customEvent = new CustomEvent(`scroll-fade:${eventName}`, {\n    detail: { scrollFade: instance, ...data },\n    bubbles: true,\n  });\n  container.dispatchEvent(customEvent);\n}\n\n// Gets text direction using Intl.Locale API for RTL detection\nexport function getTextDirection() {\n  try {\n    const locale = new Intl.Locale(navigator.language);\n    if (locale.getTextInfo) {\n      return locale.getTextInfo().direction;\n    }\n  } catch {\n    // Fallback if Intl.Locale.getTextInfo is not supported\n  }\n\n  // Fallback: check document direction\n  const dir = document.documentElement.getAttribute('dir');\n  if (dir) return dir;\n\n  // Final fallback: check computed style\n  return getComputedStyle(document.documentElement).direction || 'ltr';\n}\n\n// Checks if the container has scrollable content\nexport function isScrollable(container, orientation) {\n  if (orientation === 'horizontal') {\n    return container.scrollWidth > container.clientWidth;\n  }\n  return container.scrollHeight > container.clientHeight;\n}\n\n// Gets the current scroll position\nexport function getScrollPosition(container, orientation) {\n  if (orientation === 'horizontal') {\n    return container.scrollLeft;\n  }\n  return container.scrollTop;\n}\n\n// Calculates the maximum scroll value\nexport function getMaxScroll(container, orientation) {\n  if (orientation === 'horizontal') {\n    return container.scrollWidth - container.clientWidth;\n  }\n  return container.scrollHeight - container.clientHeight;\n}\n\n// Checks if scroll is at the start (within threshold)\nexport function isAtStart(container, orientation) {\n  const position = getScrollPosition(container, orientation);\n  return position <= EDGE_THRESHOLD;\n}\n\n// Checks if scroll is at the end (within threshold)\nexport function isAtEnd(container, orientation) {\n  const position = getScrollPosition(container, orientation);\n  const maxScroll = getMaxScroll(container, orientation);\n  return position >= maxScroll - EDGE_THRESHOLD;\n}\n\n// Gets the scroll step value (configured or default to container size)\nexport function getScrollStep(container, config) {\n  if (config.step !== null) {\n    return config.step;\n  }\n\n  // Default to container client size\n  if (config.orientation === 'horizontal') {\n    return container.clientWidth;\n  }\n  return container.clientHeight;\n}\n","// Core ScrollFade class implementation\n\nimport { selectors, attributes, classes, events } from './config.js';\nimport {\n  generateUniqueId,\n  parseConfig,\n  emit,\n  getTextDirection,\n  isScrollable,\n  isAtStart,\n  isAtEnd,\n  getMaxScroll,\n  getScrollStep,\n} from './utils.js';\n\nexport class ScrollFade {\n  constructor(container) {\n    this.id = generateUniqueId();\n    this.container = container;\n    this.config = parseConfig(container);\n\n    this.state = {\n      isAtStart: true,\n      isAtEnd: false,\n      isVisible: true,\n      isScrollable: false,\n    };\n\n    // Element references\n    this.startShadow = null;\n    this.endShadow = null;\n    this.prevBtn = null;\n    this.nextBtn = null;\n\n    // Bound handlers for cleanup\n    this.boundHandlers = null;\n\n    // Observers\n    this.resizeObserver = null;\n    this.intersectionObserver = null;\n\n    // RAF tracking\n    this.rafId = null;\n\n    // Initialize\n    const initialized = this.init();\n    if (initialized) {\n      this.container._scrollFade = this;\n      this.container.setAttribute(attributes.id, this.id);\n    }\n  }\n\n  init() {\n    // Validate container has overflow CSS\n    this.validateOverflow();\n\n    // Check initial scrollability\n    this.state.isScrollable = isScrollable(\n      this.container,\n      this.config.orientation\n    );\n\n    // Create and inject shadow elements\n    this.createShadowElements();\n\n    // Setup observers\n    this.setupObservers();\n\n    // Bind event handlers\n    this.bindHandlers();\n\n    // Wire navigation buttons if present\n    this.wireNavigationButtons();\n\n    // Update initial state and fire events\n    this.updateState(true);\n\n    return true;\n  }\n\n  validateOverflow() {\n    const style = getComputedStyle(this.container);\n    const prop =\n      this.config.orientation === 'horizontal' ? 'overflowX' : 'overflowY';\n    const overflow = style[prop];\n\n    if (overflow !== 'auto' && overflow !== 'scroll') {\n      console.warn(\n        `ScrollFade: Container should have overflow-${this.config.orientation === 'horizontal' ? 'x' : 'y'}: auto or scroll.`,\n        this.container\n      );\n    }\n  }\n\n  createShadowElements() {\n    const isRtl = getTextDirection() === 'rtl';\n    const isHorizontal = this.config.orientation === 'horizontal';\n\n    // Create start shadow\n    this.startShadow = document.createElement('div');\n    this.startShadow.setAttribute('data-scroll-fade', 'start');\n    this.startShadow.setAttribute('aria-hidden', 'true');\n    this.startShadow.style.position = 'absolute';\n    this.startShadow.style.pointerEvents = 'none';\n\n    // Create end shadow\n    this.endShadow = document.createElement('div');\n    this.endShadow.setAttribute('data-scroll-fade', 'end');\n    this.endShadow.setAttribute('aria-hidden', 'true');\n    this.endShadow.style.position = 'absolute';\n    this.endShadow.style.pointerEvents = 'none';\n\n    // Apply edge positions based on orientation and RTL\n    if (isHorizontal) {\n      if (isRtl) {\n        // RTL: start is right, end is left\n        this.startShadow.style.right = '0';\n        this.endShadow.style.left = '0';\n      } else {\n        // LTR: start is left, end is right\n        this.startShadow.style.left = '0';\n        this.endShadow.style.right = '0';\n      }\n      this.startShadow.style.top = '0';\n      this.endShadow.style.top = '0';\n    } else {\n      // Vertical: start is top, end is bottom\n      this.startShadow.style.top = '0';\n      this.startShadow.style.left = '0';\n      this.endShadow.style.bottom = '0';\n      this.endShadow.style.left = '0';\n    }\n\n    // Append to container\n    this.container.appendChild(this.startShadow);\n    this.container.appendChild(this.endShadow);\n  }\n\n  setupObservers() {\n    // ResizeObserver for dynamic scrollability changes\n    this.resizeObserver = new ResizeObserver(() => {\n      this.recalculate();\n    });\n    this.resizeObserver.observe(this.container);\n\n    // IntersectionObserver to pause when not visible\n    this.intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        const entry = entries[0];\n        this.state.isVisible = entry.isIntersecting;\n      },\n      { threshold: 0 }\n    );\n    this.intersectionObserver.observe(this.container);\n  }\n\n  bindHandlers() {\n    this.boundHandlers = {\n      scroll: () => this.handleScroll(),\n    };\n\n    this.container.addEventListener('scroll', this.boundHandlers.scroll, {\n      passive: true,\n    });\n  }\n\n  wireNavigationButtons() {\n    // Find prev button\n    this.prevBtn = document.querySelector(selectors.prev);\n    if (\n      this.prevBtn &&\n      this.prevBtn.closest(selectors.container) !== this.container\n    ) {\n      // Check if button is a sibling or within same parent scope\n      // For now, accept buttons anywhere in document that match selector\n    }\n\n    // Find next button\n    this.nextBtn = document.querySelector(selectors.next);\n\n    if (this.prevBtn) {\n      this.prevBtn.addEventListener('click', () => this.scrollPrev());\n    }\n\n    if (this.nextBtn) {\n      this.nextBtn.addEventListener('click', () => this.scrollNext());\n    }\n  }\n\n  handleScroll() {\n    // Skip if not visible (IntersectionObserver optimization)\n    if (!this.state.isVisible) return;\n\n    // Use RAF for smooth updates\n    if (this.rafId) {\n      cancelAnimationFrame(this.rafId);\n    }\n\n    this.rafId = requestAnimationFrame(() => {\n      this.updateState(false);\n    });\n  }\n\n  updateState(isInitial) {\n    const wasAtStart = this.state.isAtStart;\n    const wasAtEnd = this.state.isAtEnd;\n    const wasScrollable = this.state.isScrollable;\n\n    // Recalculate state\n    this.state.isScrollable = isScrollable(\n      this.container,\n      this.config.orientation\n    );\n    this.state.isAtStart = isAtStart(this.container, this.config.orientation);\n    this.state.isAtEnd = isAtEnd(this.container, this.config.orientation);\n\n    // If not scrollable, both shadows should be hidden\n    if (!this.state.isScrollable) {\n      this.updateShadowVisibility('start', false, isInitial);\n      this.updateShadowVisibility('end', false, isInitial);\n      this.updateButtonStates();\n      return;\n    }\n\n    // Update start shadow visibility\n    const startVisible = !this.state.isAtStart;\n    const startWasVisible = wasScrollable && !wasAtStart;\n\n    if (isInitial || startVisible !== startWasVisible) {\n      this.updateShadowVisibility('start', startVisible, isInitial);\n    }\n\n    // Update end shadow visibility\n    const endVisible = !this.state.isAtEnd;\n    const endWasVisible = wasScrollable && !wasAtEnd;\n\n    if (isInitial || endVisible !== endWasVisible) {\n      this.updateShadowVisibility('end', endVisible, isInitial);\n    }\n\n    // Emit reach events\n    if (!isInitial) {\n      if (this.state.isAtStart && !wasAtStart) {\n        emit(this, events.reachStart);\n      }\n      if (this.state.isAtEnd && !wasAtEnd) {\n        emit(this, events.reachEnd);\n      }\n    } else {\n      // Fire initial reach events if at edge\n      if (this.state.isAtStart) {\n        emit(this, events.reachStart);\n      }\n      if (this.state.isAtEnd) {\n        emit(this, events.reachEnd);\n      }\n    }\n\n    // Update button states\n    this.updateButtonStates();\n  }\n\n  updateShadowVisibility(edge, visible, isInitial) {\n    const shadow = edge === 'start' ? this.startShadow : this.endShadow;\n\n    if (visible) {\n      shadow.classList.remove(classes.hidden);\n    } else {\n      shadow.classList.add(classes.hidden);\n    }\n\n    // Emit show/hide event\n    const eventName = visible ? events.show : events.hide;\n    emit(this, eventName, { edge });\n  }\n\n  updateButtonStates() {\n    if (this.prevBtn) {\n      if (this.state.isAtStart || !this.state.isScrollable) {\n        this.prevBtn.classList.add(classes.buttonDisabled);\n        this.prevBtn.setAttribute('aria-disabled', 'true');\n      } else {\n        this.prevBtn.classList.remove(classes.buttonDisabled);\n        this.prevBtn.removeAttribute('aria-disabled');\n      }\n    }\n\n    if (this.nextBtn) {\n      if (this.state.isAtEnd || !this.state.isScrollable) {\n        this.nextBtn.classList.add(classes.buttonDisabled);\n        this.nextBtn.setAttribute('aria-disabled', 'true');\n      } else {\n        this.nextBtn.classList.remove(classes.buttonDisabled);\n        this.nextBtn.removeAttribute('aria-disabled');\n      }\n    }\n  }\n\n  scrollPrev() {\n    const step = getScrollStep(this.container, this.config);\n    const isRtl = getTextDirection() === 'rtl';\n    const isHorizontal = this.config.orientation === 'horizontal';\n\n    if (isHorizontal) {\n      // In RTL, \"prev\" scrolls right (positive)\n      const scrollAmount = isRtl ? step : -step;\n      this.container.scrollBy({\n        left: scrollAmount,\n        behavior: 'smooth',\n      });\n    } else {\n      this.container.scrollBy({\n        top: -step,\n        behavior: 'smooth',\n      });\n    }\n  }\n\n  scrollNext() {\n    const step = getScrollStep(this.container, this.config);\n    const isRtl = getTextDirection() === 'rtl';\n    const isHorizontal = this.config.orientation === 'horizontal';\n\n    if (isHorizontal) {\n      // In RTL, \"next\" scrolls left (negative)\n      const scrollAmount = isRtl ? -step : step;\n      this.container.scrollBy({\n        left: scrollAmount,\n        behavior: 'smooth',\n      });\n    } else {\n      this.container.scrollBy({\n        top: step,\n        behavior: 'smooth',\n      });\n    }\n  }\n\n  recalculate() {\n    this.updateState(false);\n  }\n\n  // Public API\n\n  scrollToStart() {\n    const isHorizontal = this.config.orientation === 'horizontal';\n    const isRtl = getTextDirection() === 'rtl';\n\n    if (isHorizontal) {\n      const scrollTarget = isRtl\n        ? getMaxScroll(this.container, this.config.orientation)\n        : 0;\n      this.container.scrollTo({\n        left: scrollTarget,\n        behavior: 'smooth',\n      });\n    } else {\n      this.container.scrollTo({\n        top: 0,\n        behavior: 'smooth',\n      });\n    }\n\n    return this;\n  }\n\n  scrollToEnd() {\n    const isHorizontal = this.config.orientation === 'horizontal';\n    const isRtl = getTextDirection() === 'rtl';\n    const maxScroll = getMaxScroll(this.container, this.config.orientation);\n\n    if (isHorizontal) {\n      const scrollTarget = isRtl ? 0 : maxScroll;\n      this.container.scrollTo({\n        left: scrollTarget,\n        behavior: 'smooth',\n      });\n    } else {\n      this.container.scrollTo({\n        top: maxScroll,\n        behavior: 'smooth',\n      });\n    }\n\n    return this;\n  }\n\n  refresh() {\n    // Disconnect observers\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n    }\n\n    // Reconnect observers\n    this.setupObservers();\n\n    // Recalculate state\n    this.updateState(false);\n\n    return this;\n  }\n\n  destroy() {\n    // Cancel any pending RAF\n    if (this.rafId) {\n      cancelAnimationFrame(this.rafId);\n    }\n\n    // Disconnect observers\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n    }\n\n    // Remove event listeners\n    if (this.boundHandlers) {\n      this.container.removeEventListener('scroll', this.boundHandlers.scroll);\n    }\n\n    // Remove navigation button listeners (by removing references)\n    // Note: We can't remove click listeners without storing bound references\n    // For simplicity, we just null the references\n    this.prevBtn = null;\n    this.nextBtn = null;\n\n    // Remove shadow elements from DOM\n    if (this.startShadow && this.startShadow.parentNode) {\n      this.startShadow.parentNode.removeChild(this.startShadow);\n    }\n    if (this.endShadow && this.endShadow.parentNode) {\n      this.endShadow.parentNode.removeChild(this.endShadow);\n    }\n\n    // Remove instance reference from container\n    delete this.container._scrollFade;\n\n    // Remove instance ID attribute\n    this.container.removeAttribute(attributes.id);\n  }\n}\n","// ScrollFade entry point with auto-initialization\n\nimport { selectors } from './config.js';\nimport { ScrollFade } from './core.js';\n\n// Auto-initialize all scroll-fade containers\nfunction autoInit() {\n  const containers = document.querySelectorAll(selectors.container);\n\n  containers.forEach((container) => {\n    // Skip already initialized containers\n    if (container._scrollFade) return;\n\n    try {\n      new ScrollFade(container);\n    } catch (error) {\n      console.warn('ScrollFade auto-initialization failed:', error);\n    }\n  });\n}\n\n// Run auto-init when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\n// Export for manual usage\nexport { ScrollFade };\n"],"names":["selectors","attributes","classes","events","defaults","idCounter","emit","instance","eventName","data","container","customEvent","CustomEvent","detail","scrollFade","bubbles","dispatchEvent","getTextDirection","locale","Intl","Locale","navigator","language","getTextInfo","direction","dir","document","documentElement","getAttribute","getComputedStyle","isScrollable","orientation","scrollWidth","clientWidth","scrollHeight","clientHeight","getScrollPosition","scrollLeft","scrollTop","getMaxScroll","getScrollStep","config","step","ScrollFade","constructor","this","id","stepAttr","parseInt","parseConfig","state","isAtStart","isAtEnd","isVisible","startShadow","endShadow","prevBtn","nextBtn","boundHandlers","resizeObserver","intersectionObserver","rafId","init","_scrollFade","setAttribute","validateOverflow","createShadowElements","setupObservers","bindHandlers","wireNavigationButtons","updateState","overflow","console","warn","isRtl","isHorizontal","createElement","style","position","pointerEvents","right","left","top","bottom","appendChild","ResizeObserver","recalculate","observe","IntersectionObserver","entries","entry","isIntersecting","threshold","scroll","handleScroll","addEventListener","passive","querySelector","closest","scrollPrev","scrollNext","cancelAnimationFrame","requestAnimationFrame","isInitial","wasAtStart","wasAtEnd","wasScrollable","updateShadowVisibility","updateButtonStates","startVisible","endVisible","edge","visible","shadow","classList","remove","add","removeAttribute","scrollAmount","scrollBy","behavior","scrollToStart","scrollTarget","scrollTo","scrollToEnd","maxScroll","refresh","disconnect","destroy","removeEventListener","parentNode","removeChild","autoInit","querySelectorAll","forEach","error","readyState"],"mappings":"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"}